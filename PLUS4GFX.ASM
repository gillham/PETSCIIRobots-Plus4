;PETSCII ROBOTS (Plus4 GFX version)
;by David Murray 2020
;dfwgreencars@gmail.com
;ported by Jim Wright 2021
;jim@a1pro.net

!to "plus4gfx.prg",cbm

*=$1000				;START ADDRESS IS $1000

	JSR	SETUP_INTERRUPT	;Sets up the interrupt and disable upper ROM.
	JSR	SET_CONTROLS	;copy initial key controls
	JMP	INTRO_SCREEN

!SOURCE "DEFINITIONS.ASM"
!SOURCE "GRAPHICS.ASM"
!SOURCE "SOUND.ASM"
!SOURCE "BACKGROUND_TASKS.ASM"

INIT_GAME:
	LDX	#0
	STX	SCREEN_SHAKE
	INX
	STX	PLAYER_DIR
	
	;Change player color to white (prevents them from staying red after dying)
	LDA #$71
	JSR PLAYER_COLOR
	
	;Reset Ammo, Inventory, Keys, and Timer
	LDA	#$00
	LDX #12
RESKA1:
	DEX
	STA INVENTORY,X
	BNE RESKA1
	STA	CYCLES
	STA	SECONDS
	STA	MINUTES
	STA	HOURS

	JSR	DISPLAY_GAME_SCREEN
	JSR DISPLAY_WEAPON
	JSR DISPLAY_ITEM
	JSR	DISPLAY_LOAD_MESSAGE2
	
	;Load the level map
	SEI
	STA $FF3E
	LDA #<MAP_DATA
	STA ZP0
	LDA #>MAP_DATA
	STA ZP1
	LDA	#MAPNAME_END-MAPNAME
	LDX	#<MAPNAME
	LDY	#>MAPNAME
	JSR LOAD
	STA $FF3F
	CLI

	JSR	SET_DIFF_LEVEL
	JSR	ANIMATE_PLAYER
	JSR	CACULATE_AND_REDRAW
	JSR	DRAW_MAP_WINDOW
	JSR	DISPLAY_PLAYER_HEALTH
	JSR	DISPLAY_KEYS
	;LDA	#15
	;STA	SID+$0018			;volume
	;JSR	START_LEVEL_MUSIC
	LDA	#1
	STA	UNIT_TYPE
	LDA #97
	STA UNIT_TILE
	JSR	SET_INITIAL_TIMERS
	JSR	PRINT_INTRO_MESSAGE
	LDA	#30
	STA	KEYTIMER
	JMP	MAIN_GAME_LOOP

SETUP_INTERRUPT:
	SEI				; Disable interrupt routine
	;Setup IRQ to visit the routine at RUNIRQ
	LDA #<RUNIRQ
	STA $FFFE
	LDA #>RUNIRQ
	STA $FFFF
	STA $FF3F		; Disable upper ROM from $8000-$FFFF
	LDA #$A1
	STA $FF0B		; Raster line to execute interrupt
	CLI				; Enable interrupts
	RTS

;This is the routine that runs every 60 seconds from the IRQ.
;BGTIMER1 is always set to 1 every cycle, after which the main
;program will reset it to 0 when it is done with it's work for
;that cycle.  BGTIMER2 is a count-down to zero and then stays
;there.
RUNIRQ:
	PHA				;Push registers onto the stack
	TXA
	PHA
	TYA
	PHA
MAIN_INTERRUPT:	
	LDA	MUSIC_STATE
	CMP	#0
	BEQ	IRQ0
	LDA SOUND_PLAYING
	CMP #$FF
	BEQ IRQ00			;Save values in the sound registers before calling the music routine
	LDA $ff0f
	STA ZIRQ0
	LDA $ff10
	STA ZIRQ1
	LDA $ff11
	STA ZIRQ2
	JSR MUSIC+$0003
	LDA ZIRQ0			;Restore values in the sound registers
	STA $ff0f
	LDA ZIRQ1
	STA $ff10
	LDA ZIRQ2
	STA $ff11
	JMP IRQ0
IRQ00:
	JSR	MUSIC+$0003		;Music play routine
IRQ0:					;Sound routine for playing TED sounds
	LDA SOUND_PLAYING
	CMP #$FF
	BEQ IRQ1			;Not playing a sound currently, skip
	JSR IRQ_PLAY_SOUND
IRQ1:	
	JSR	UPDATE_GAME_CLOCK
	JSR	ANIMATE_WATER
	LDA	#1
	STA	BGTIMER1
	LDA	BGTIMER2
	CMP	#0
	BEQ	IRQ2
	DEC	BGTIMER2
IRQ2:
	LDA	KEYTIMER
	CMP	#0
	BEQ	IRQ3
	DEC	KEYTIMER
IRQ3:	;BORDER FLASHER
	LDX	BORDER
	CPX	#0
	BEQ	IRQ4
	LDA	BORDER,X
	STA	BORDER_COLOR
	DEC	BORDER
IRQ4:	;BACKGROUND FLASHER
	LDX	BGFLASH
	CPX	#0
	BEQ	IRQ10
	LDA	BGFLASH,X
	STA	BACKGROUND_COLOR
	DEC	BGFLASH
IRQ10:	;SCREEN_SHAKER
	LDA	SCREEN_SHAKE
	CMP	#$00
;	BEQ	SHAKE4
	BEQ	IRQ20
SHAKE2:
	INC	SSCOUNT
	LDA	SSCOUNT
	CMP	#5
	BNE	SHAKE3
	LDA	#0
	STA	SSCOUNT
SHAKE3:
	LDY	SSCOUNT
	LDA	$FF07
	AND	#%11111000
	ORA	SSHAKE,Y
	STA	$FF07
	;CHECK TO SEE IF KEYBOARD WAS DISABLED	
	;This routine causes the kernal to skip keyboard
	;input for one cycle to help "debounce" the 
	;keyboard.
IRQ20:
	LDA	KEYBOARD_QUEUE_LENGTH	;1=normal 0=disabled
	CMP	#0
	BNE	IRQ30
	LDA	KEYSOFF
	CMP	#0
	BNE	IRQ21
	INC KEYSOFF
	JMP	IRQ30
IRQ21:
	LDA	#0
	STA	KEYSOFF
	LDA	#1
	STA	KEYBOARD_QUEUE_LENGTH	;turn keyboard back on
IRQ30:	;Animate Sprite Color
	DEC	SPRITECOLTIMER
	LDA	SPRITECOLTIMER
	CMP	#0
	BNE	IRQ32
	LDA	#3
	STA	SPRITECOLTIMER
	LDY	SPRITECOLSTATE
	LDA	SPRITECOLCHART,Y
	STA	ANIM_COLOR
	INY
	CPY	#16
	BNE	IRQ31
	LDY	#0
IRQ31:
	STY	SPRITECOLSTATE
IRQ32:
	LDX	CURSOR_ON
	CPX	#1
	BNE ENDIRQ
	JSR DISPLAY_CURSOR 	;Draw cursor if it is on
ENDIRQ:
	LDA #$02
	STA $FF09
	;Return from interrupt
	PLA
	TAY
	PLA
	TAX
	PLA
	RTI
	
BGTIMER1		!BYTE 00
BGTIMER2		!BYTE 00
KEYTIMER		!BYTE 00
KEYSOFF			!BYTE 00	
BORDER			!BYTE $00,$06,$22,$38,$38,$67,$67,$67,$38,$38,$22
BGFLASH			!BYTE $00,$00,$16,$46,$46,$71,$71,$71,$46,$46,$16
SPRITECOLCHART	!BYTE $00,$01,$11,$21,$31,$41,$51,$61,$71,$61,$51,$41,$31,$21,$11,$01
SPRITECOLSTATE	!BYTE 00
SPRITECOLTIMER	!BYTE 08
SSHAKE			!BYTE 00,02,04,02,00
SSCOUNT			!BYTE 00

;Since the PET OR VIC-20 has no real-time clock, and the Jiffy clock
;is a pain to read from assembly language, I have created my own.
;This could be updated in future to use the 6510's real-time clock
;for C64.
UPDATE_GAME_CLOCK:
	LDA	CLOCK_ACTIVE
	CMP	#1
	BNE	UGC5
	INC	CYCLES
	LDA	CYCLES
	CMP	#UPDATE_FREQ	
	BNE	UGC5
	LDA	#0
	STA	CYCLES
	INC	SECONDS
	LDA	SECONDS
	CMP	#60	
	BNE	UGC5
	LDA	#0
	STA	SECONDS
	INC	MINUTES
	LDA	MINUTES
	CMP	#60	
	BNE	UGC5
	LDA	#0
	STA	SECONDS
	STA	MINUTES
	INC	HOURS
UGC5:	RTS

HOURS			!BYTE	00
MINUTES			!BYTE	00
SECONDS			!BYTE	00
CYCLES			!BYTE	00
CLOCK_ACTIVE	!BYTE	00

GETKEY:
	;Disable interrupts and call kernal routines for checking keyboard input
	SEI
	STA $FF3E
	JSR SCANKEY
	JSR	KEYIN
	STA $FF3F
	CLI
	RTS
	
SNES_CONTROLER_READ:
	;First copy last time's results to the LAST variables.
	LDY	#0
SNCL:	LDA	SNES_B,Y
	STA	LAST_B,Y
	;STA	$8398,Y		;TESTCODE
	INY
	CPY	#12
	BNE	SNCL
	;now latch data
	LDA	#%01000010	;latch on pin 6
	STA	USER_PORT	
	LDA	#%00000010
	STA	USER_PORT
	LDX	#0
	;Now read in bits
SRLOOP:	LDA	USER_PORT
	AND	#%00000010	;READ pin 2
	CMP	#%00000010
	BEQ	SRL1
	LDA	#1
	JMP	SRL5
SRL1:	LDA	#0
SRL5:	STA	SNES_B,X
	;pulse the clock line
	LDA	#%10000010	;CLOCK on pin 7
	STA	USER_PORT
	LDA	#%00000010
	STA	USER_PORT
	INX
	CPX	#12
	BNE	SRLOOP
	;now process any new presses
	LDY	#0
SRL09:	LDA	NEW_B,Y
	CMP	#1
	BEQ	SRL10
	LDA	SNES_B,Y
	CMP	#1
	BNE	SRL10
	LDA	LAST_B,Y
	CMP	#0
	BNE	SRL10
	LDA	#1
	STA	NEW_B,Y
SRL10:	INY
	CPY	#12
	BNE	SRL09
	RTS

;This routine spaces out the timers so that not everything
;is running out once. It also starts the game_clock. 
SET_INITIAL_TIMERS:
	LDA	#1
	STA	CLOCK_ACTIVE
	LDX	#01
SIT1	TXA
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_TIMER_B,X
	INX	
	CPX	#48
	BNE	SIT1
	RTS

MAIN_GAME_LOOP:
	JSR	BACKGROUND_TASKS
	LDA	UNIT_TYPE
	CMP	#1	;Is player unit alive
	BEQ	MG00
	JMP	GAME_OVER
MG00:	LDA	CONTROL
	CMP	#2
	BNE	KY01
	JMP	SC01
KY01:	;Keyboard controls here.
	JSR	KEY_REPEAT
	JSR GETKEY
	CMP	#$00
	BEQ	MAIN_GAME_LOOP
	JSR	CLEAR_KEY_BUFFER
MG01:	CMP	#$1D	;CURSOR RIGHT
	BNE	MG02
MG01A:	LDA	#3
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_RIGHT
	JMP	AFTER_MOVE
MG02:	CMP	#$9D	;CURSOR LEFT
	BNE	MG03
MG02A:	LDA	#2
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_LEFT
	JMP	AFTER_MOVE
MG03:	CMP	#$11	;CURSOR DOWN
	BNE	MG04
MG03A:	LDA	#1
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_DOWN
	JMP	AFTER_MOVE
MG04:	CMP	#$91	;CURSOR UP
	BNE	MG05
MG04A:	LDA	#0
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_UP
	JMP	AFTER_MOVE
MG05:	CMP	KEY_CYCLE_WEAPONS
	BNE	MG06
	JSR	CYCLE_WEAPON
	;JSR	CLEAR_KEY_BUFFER
	JMP	MAIN_GAME_LOOP
MG06:	CMP	KEY_CYCLE_ITEMS
	BNE	MG07
	JSR	CYCLE_ITEM
	;JSR	CLEAR_KEY_BUFFER
	JMP	MAIN_GAME_LOOP
MG07:	CMP	KEY_MOVE
	BNE	MG08
	JSR	MOVE_OBJECT
	JSR	CLEAR_KEY_BUFFER
	JMP	MAIN_GAME_LOOP	
MG08:	CMP	KEY_SEARCH
	BNE	MG09
	JSR	SEARCH_OBJECT
	JSR	CLEAR_KEY_BUFFER
	JMP	MAIN_GAME_LOOP
MG09:	CMP	KEY_USE
	BNE	MG10
	JSR	USE_ITEM
	JSR	CLEAR_KEY_BUFFER
	JMP	MAIN_GAME_LOOP
MG10:	CMP	KEY_MOVE_LEFT
	BNE	MG11
	JMP	MG02A	
MG11:	CMP	KEY_MOVE_DOWN
	BNE	MG12
	JMP	MG03A
MG12:	CMP	KEY_MOVE_RIGHT
	BNE	MG13
	JMP	MG01A
MG13:	CMP	KEY_MOVE_UP
	BNE	MG14
	JMP	MG04A
MG14:	CMP	KEY_FIRE_UP
	BNE	MG15
	LDA #12	;AI Routine for firing up
	JSR	FIRE_VERTICAL
	LDA	#20
	STA	KEYTIMER
	JMP	MAIN_GAME_LOOP
MG15:	CMP	KEY_FIRE_LEFT
	BNE	MG16
	LDA #14	;AI Routine for firing left
	JSR	FIRE_HORIZONTAL
	LDA	#20
	STA	KEYTIMER
	JMP	MAIN_GAME_LOOP
MG16:	CMP	KEY_FIRE_DOWN
	BNE	MG17
	LDA #13	;AI Routine for firing down
	JSR	FIRE_VERTICAL
	LDA	#20
	STA	KEYTIMER
	JMP	MAIN_GAME_LOOP
MG17:	CMP	KEY_FIRE_RIGHT
	BNE	MG18
	LDA #15	;AI Routine for firing right
	JSR	FIRE_HORIZONTAL
	LDA	#20
	STA	KEYTIMER
	JMP	MAIN_GAME_LOOP
MG18:	CMP	#03	;RUN/STOP
	BNE	MG19
	JMP	PAUSE_GAME
MG19:	CMP #27	;escape key
	BNE MG20
	JMP	PAUSE_GAME
MG20:	CMP	CHEAT	;C= + * (cheat mode)
	BNE	MG21
	JSR	CHEATER
	JMP	MAIN_GAME_LOOP
MG21:	;CMP	#205	;SHIFT-M
	;BNE	MG22
	;JSR	TOGGLE_MUSIC
	;JMP MAIN_GAME_LOOP
MG22:	CMP FUNC8
	BNE MG23
	JSR	DISPLAY_MAP
MG23:	JMP	MAIN_GAME_LOOP

SC01:	;SNES CONTROLLER starts here
	JSR	SNES_CONTROLER_READ
SC011:
	;check keytimer for repeat time.
	LDA	KEYTIMER
	CMP	#0
	BEQ	SC02
	JMP	SC40
SC02:	LDA	#0
	STA	NEW_UP
	STA	NEW_DOWN
	STA	NEW_LEFT
	STA	NEW_RIGHT
	STA	SNES_UP
	STA	SNES_DOWN
	STA	SNES_LEFT
	STA	SNES_RIGHT
	JSR	SNES_CONTROLER_READ
SC05:	;first we start with the 4 directional buttons.
	LDA	NEW_LEFT
	CMP	#01
	BNE	SC10
	LDA	#2
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_LEFT
	JMP	AFTER_MOVE_SNES	
SC10:	LDA	NEW_RIGHT
	CMP	#01
	BNE	SC20
	LDA	#3
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_RIGHT
	JMP	AFTER_MOVE_SNES
SC20:	LDA	NEW_UP
	CMP	#01
	BNE	SC30
	LDA	#0
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_UP
	JMP	AFTER_MOVE_SNES
SC30:	LDA	NEW_DOWN
	CMP	#01
	BNE	SC35
	LDA	#1
	STA	PLAYER_DIR
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_DOWN
	JMP	AFTER_MOVE_SNES
SC35:	LDA	#0
	STA	KEY_FAST
SC40:	;Now check for non-repeating buttons
	LDA	NEW_Y
	CMP	#1
	BNE	SC45
	LDA #14	;AI Routine for firing left
	JSR	FIRE_HORIZONTAL
	LDA	#0
	STA	NEW_Y
SC45:	LDA	NEW_A
	CMP	#1
	BNE	SC50
	LDA #15	;AI Routine for firing right
	JSR	FIRE_HORIZONTAL
	LDA	#0
	STA	NEW_A
SC50:	LDA	NEW_X
	CMP	#1
	BNE	SC55
	LDA #12	;AI Routine for firing up
	JSR	FIRE_VERTICAL
	LDA	#0
	STA	NEW_X
SC55:	LDA	NEW_B
	CMP	#1
	BNE	SC60
	LDA #13	;AI Routine for firing down
	JSR	FIRE_VERTICAL
	LDA	#0
	STA	NEW_B
SC60:	LDA	NEW_BACK_L
	CMP	#1
	BNE	SC65
	LDA	SNES_SELECT
	CMP	#1
	BNE	SC62
	JSR	CYCLE_ITEM
	JMP	SC63
SC62:	JSR	SEARCH_OBJECT
SC63:	LDA	#0
	STA	NEW_BACK_L
	LDA	#15
	STA	KEYTIMER
SC65:	LDA	NEW_BACK_R
	CMP	#1
	BNE	SC70
	LDA	SNES_SELECT
	CMP	#1
	BNE	SC67
	JSR	CYCLE_WEAPON
	JMP	SC68
SC67:	JSR	MOVE_OBJECT
SC68:	LDA	#0
	STA	NEW_BACK_R
	LDA	#15
	STA	KEYTIMER
SC70:	LDA	NEW_START
	CMP	#1
	BNE	SC75
	JSR	USE_ITEM
	LDA	#0
	STA	NEW_START
	LDA	#15
	STA	KEYTIMER
SC75:	;STILL USE KEYBOARD TO CHECK FOR RUN/STOP AND PET MODE
	JSR GETKEY
	CMP	#03	;RUN/STOP
	BNE	SC82
	JMP	PAUSE_GAME
SC82:
	CMP	#27	;ESC
	BNE	SC83
	JMP	PAUSE_GAME
SC83:
	;CMP	#205	;SHIFT-M
	;BNE	SC84
	;JSR	TOGGLE_MUSIC
	;JSR	CLEAR_KEY_BUFFER
	CMP	CHEAT	;C= + * (cheat mode)
	BNE	SC84
	JSR	CHEATER
	JMP	MAIN_GAME_LOOP
SC84:
	CMP FUNC8
	BNE SC85
	JSR	DISPLAY_MAP
SC85:	JMP	MAIN_GAME_LOOP



;This routine handles things that are in common to
;all 4 directions of movement.
AFTER_MOVE_SNES:
	LDA	MOVE_RESULT
	CMP	#1
	BNE	AMS01
	JSR	ANIMATE_PLAYER
	JSR	CACULATE_AND_REDRAW
AMS01:	LDA	KEY_FAST
	CMP	#0
	BNE	AMS02
	LDA	#15
	STA	KEYTIMER
	LDA	#1
	STA	KEY_FAST
	JMP	AMS03
AMS02:	LDA	#6
	STA	KEYTIMER
	LDA	#0
	STA	NEW_UP
	STA	NEW_DOWN
	STA	NEW_LEFT
	STA	NEW_RIGHT
AMS03:	JMP	MAIN_GAME_LOOP

;TEMP ROUTINE TO GIVE ME ALL ITEMS AND WEAPONS
CHEATER:
	LDA	#1	
	STA	SELECTED_WEAPON		
	STA	SELECTED_ITEM	
	LDA	#7
	STA	KEYS			
	TAX
	LDA	#100
CHEAT1:
	DEX
	BEQ CHEAT2
	STA INVENTORY,X
	BNE CHEAT1
CHEAT2:
	JSR	DISPLAY_KEYS
	JSR	DISPLAY_WEAPON
	JSR	DISPLAY_ITEM	
	RTS

PAUSE_GAME:
	LDX	#SOUND_MENU_BEEP
	JSR	PLAY_SOUND	;SOUND PLAY
	;pause clock
	LDA	#0
	STA	CLOCK_ACTIVE
	;display message to user
	JSR	SCROLL_INFO
	LDA	#<MSG_PAUSED
	STA	ZP0
	LDA	#>MSG_PAUSED
	STA	ZP1
	JSR	PRINT_INFO
	JSR	CLEAR_KEY_BUFFER
PG1:
	JSR GETKEY
	CMP	#$00
	BEQ	PG1
	CMP	#03	;RUN/STOP
	BEQ	PG5
	CMP	#27	;ESC
	BEQ	PG5
	CMP	#78	;N-KEY
	BEQ	PG5	
	CMP	#89	;Y-KEY
	BEQ	PG6
	JMP	PG1
PG5:	LDX	#SOUND_MENU_BEEP
	JSR	PLAY_SOUND	;SOUND PLAY
	JSR	SCROLL_INFO
	JSR	SCROLL_INFO
	JSR	SCROLL_INFO
	JSR	CLEAR_KEY_BUFFER
	LDA	#1
	STA	CLOCK_ACTIVE
	JMP	MAIN_GAME_LOOP
PG6:	LDA	#0
	STA	UNIT_TYPE	;make player dead
	JMP	GOM4

CLEAR_KEY_BUFFER:
	LDY	#0
	STY	KEYBOARD_QUEUE_LENGTH	;disable keyboard input
	LDY	#0
	STY KEYBOARD_CHARS_IN_QUEUE
	LDY	#20
	STY	KEYTIMER
	RTS

USE_ITEM:
	;First figure out which item to use.
	LDA	SELECTED_ITEM
	CMP	#1	;BOMB
	BNE	UI02
	JMP	USE_BOMB
UI02:	CMP	#2	;EMP
	BNE	UI03	
	JMP	USE_EMP
UI03:	CMP	#3	;MEDKIT
	BNE	UI04
	JMP	USE_MEDKIT
UI04:	CMP	#4	;MAGNET
	BNE	UI05
	JMP	USE_MAGNET
UI05:	RTS

USE_BOMB:
	JSR	USER_SELECT_OBJECT
	;NOW TEST TO SEE IF THAT SPOT IS OPEN
	JSR	BOMB_MAGNET_COMMON1
	BEQ	BM30	
	JMP	BM3A				;If not, then exit routine.
BM30:	;Now scan for any units at that location:
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255			;255 means no unit found.
	BEQ	BM31
BM3A:	JMP	BOMB_MAGNET_COMMON2
BM31:	LDX	#28	;Start of weapons units
BOMB1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	BOMB2
	INX
	CPX	#32
	BNE	BOMB1
	RTS	;no slots available right now, abort.
BOMB2:	LDA	#6	;bomb AI
	STA	UNIT_TYPE,X
	LDA	#130	;bomb tile
	STA	UNIT_TILE,X
	LDA	MAP_X
	STA	UNIT_LOC_X,X
	LDA	MAP_Y
	STA	UNIT_LOC_Y,X
	LDA	#100		;How long until exposion?
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_A,X
	DEC	INV_BOMBS
	JSR	DISPLAY_ITEM
	LDA	#01
	STA	REDRAW_WINDOW
	LDX	#SOUND_MOVEOBJ
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS

USE_MAGNET:
	LDA	MAGNET_ACT	;only one magnet active at a time.
	CMP	#0
	BEQ	MG32
	RTS
MG32:	JSR	USER_SELECT_OBJECT
	;NOW TEST TO SEE IF THAT SPOT IS OPEN
	JSR	BOMB_MAGNET_COMMON1
	BEQ	MG31	
	JMP	BOMB_MAGNET_COMMON2
MG31:	LDX	#28	;Start of weapons units
MAG1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	MAG2
	INX
	CPX	#32
	BNE	MAG1
	RTS	;no slots available right now, abort.
MAG2:	LDA	#20	;MAGNET AI
	STA	UNIT_TYPE,X
	LDA	#134	;MAGNET tile
	STA	UNIT_TILE,X
	LDA	MAP_X
	STA	UNIT_LOC_X,X
	LDA	MAP_Y
	STA	UNIT_LOC_Y,X
	LDA	#1		;How long until ACTIVATION
	STA	UNIT_TIMER_A,X
	LDA	#255		;how long does it live -A
	STA	UNIT_TIMER_B,X
	LDA	#5		;how long does it live -B
	STA	UNIT_A,X
	LDA	#1
	STA	MAGNET_ACT	;only one magnet allowed at a time.
	DEC	INV_MAGNET
	JSR	DISPLAY_ITEM
	LDA	#01
	STA	REDRAW_WINDOW
	LDX	#SOUND_MOVEOBJ
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS

BOMB_MAGNET_COMMON1:
	LDA	#0
	STA	CURSOR_ON
	JSR	DRAW_MAP_WINDOW		;ERASE THE CURSOR
	LDA	CURSOR_X
	CLC
	ADC	MAP_WINDOW_X
	STA	MAP_X
	STA	MOVTEMP_UX
	LDA	CURSOR_Y
	CLC
	ADC	MAP_WINDOW_Y
	STA	MAP_Y
	STA	MOVTEMP_UY
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	TAY
	LDA	TILE_ATTRIB,Y
	AND	#%00000001		;is that spot available	
	CMP	#%00000001		;for something to move onto it?
	RTS

BOMB_MAGNET_COMMON2:
	LDA	#<MSG_BLOCKED
	STA	ZP0
	LDA	#>MSG_BLOCKED
	STA	ZP1
	JSR	PRINT_INFO
	LDX	#SOUND_ERROR
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS	

USE_EMP:
	LDA	#10
	STA	BGFLASH	
	LDX	#SOUND_EMP		;EMP sound
	JSR	PLAY_SOUND	;SOUND PLAY	
	DEC	INV_EMP
	JSR	DISPLAY_ITEM
	LDX	#1	;start with unit#1 (skip player)
EMP1:	;CHECK THAT UNIT EXISTS
	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	EMP5
	;CHECK HORIZONTAL POSITION
	LDA	UNIT_LOC_X,X
	CMP	MAP_WINDOW_X
	BCC	EMP5
	LDA	MAP_WINDOW_X
	CLC
	ADC	#10
	CMP	UNIT_LOC_X,X
	BCC	EMP5
	;NOW CHECK VERTICAL
	LDA	UNIT_LOC_Y,X
	CMP	MAP_WINDOW_Y
	BCC	EMP5
	LDA	MAP_WINDOW_Y
	CLC
	ADC	#6
	CMP	UNIT_LOC_Y,X
	BCC	EMP5
	LDA	#255
	STA	UNIT_TIMER_A,X
	;test to see if unit is above water
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	CMP	#204	;WATER
	BNE	EMP5
	LDA	#5
	STA	UNIT_TYPE,X
	STA	UNIT_TIMER_A,X
	LDA	#60
	STA	UNIT_A,X
	LDA	#140	;Electrocuting tile
	STA	UNIT_TILE,X
EMP5:	INX	
	CPX	#28
	BNE	EMP1
	LDA	#<MSG_EMPUSED
	STA	ZP0
	LDA	#>MSG_EMPUSED
	STA	ZP1
	JSR	PRINT_INFO
	RTS

USE_MEDKIT:
	LDA	UNIT_HEALTH
	CMP	#12	;Do we even need the medkit?
	BNE	UMK1
	RTS
UMK1:	;Now figure out how many HP we need to be healthy.
	LDA	#12
	SEC
	SBC	UNIT_HEALTH
	STA	TEMP_A		;how many we need.
	LDA	INV_MEDKIT	;how many do we have?
	SEC
	SBC	TEMP_A
	BCC	UMK2
	;we had more than we need, so go to full health.
	LDA	#12
	STA	UNIT_HEALTH
	LDA	INV_MEDKIT
	SEC
	SBC	TEMP_A
	STA	INV_MEDKIT
	JMP	UMK3
UMK2:	;we had less than we need, so we'll use what is available.
	LDA	INV_MEDKIT
	CLC
	ADC	UNIT_HEALTH
	STA	UNIT_HEALTH
	LDA	#0
	STA	INV_MEDKIT
UMK3:	JSR	DISPLAY_PLAYER_HEALTH
	JSR	DISPLAY_ITEM
	LDX	#SOUND_MEDKIT
	JSR	PLAY_SOUND	;SOUND PLAY
	LDA	#<MSG_MUCHBET
	STA	ZP0
	LDA	#>MSG_MUCHBET
	STA	ZP1
	JSR	PRINT_INFO
	RTS

FIRE_HORIZONTAL:
	STA ZP0		;Store passed AI Routine
	LDA	SELECTED_WEAPON
	CMP	#0
	BNE	FH0
	RTS
FH0:
	LDX #5		;Fire distance
	STX ZP1
	CMP	#1
	BNE	FH1
	LDX #245	;Tile for horizontal pistol fire
	STX ZP2
	JMP	FIRE_PISTOL
FH1:
	LDX #241	;Tile for horizontal plasma fire
	STX ZP2
	JMP	FIRE_PLASMA

FIRE_VERTICAL:
	STA ZP0		;Store passed AI Routine
	LDA	SELECTED_WEAPON
	CMP	#0
	BNE	FV0
	RTS
FV0:
	LDX #3		;Fire distance
	STX ZP1
	CMP	#1
	BNE	FV1
	LDX #244	;Tile for vertical pistol fire
	STX ZP2
	JMP	FIRE_PISTOL
FV1:
	LDX #240	;Tile for vertical plasma fire
	STX ZP2
;	JMP	FIRE_PLASMA		;No need to jump if it is the next function anyway

FIRE_PLASMA:
	LDX BIG_EXP_ACT
	CPX #1
	BEQ FP0
	LDX PLASMA_ACT
	CPX #1
	BEQ FP0
FIRE_PISTOL:
	TAX			;Selected weapon is passed in the A register
	LDA	AMMO_PISTOL-$0001,X
	CMP	#0
	BNE	FP1
FP0:	RTS		;No ammo or weapon not ready
FP1:	LDX	#28
FP2:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	FP3
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	FP2
	RTS	
FP3:	LDA	ZP0	;Weapon fire AI routine
	STA	UNIT_TYPE,X
	LDA	ZP2	;tile for weapons fire
	STA	UNIT_TILE,X
	LDA	ZP1		;travel distance.
	STA	UNIT_A,X
	LDY	SELECTED_WEAPON	;Get weapon type and decrease it by one
	DEY
	TYA
	STA	UNIT_B,X
	CPY #0
	BEQ FP4
	STA PLASMA_ACT		;If plasma gun, mark it as active
FP4:	JMP	AFTER_FIRE

AFTER_FIRE:
	LDA	#0
	STA	UNIT_TIMER_A,X
	LDA	UNIT_LOC_X
	STA	UNIT_LOC_X,X
	LDA	UNIT_LOC_Y
	STA	UNIT_LOC_Y,X
	STX	UNIT
	LDA	SELECTED_WEAPON
	CMP	#2
	BEQ	AF01
	LDX	#SOUND_PISTOL
	JSR	PLAY_SOUND	;SOUND PLAY
	DEC	AMMO_PISTOL
	JSR	DISPLAY_WEAPON
	RTS
AF01:	LDX	#SOUND_PLASMA
	JSR	PLAY_SOUND	;SOUND PLAY
	DEC	AMMO_PLASMA
	JSR	DISPLAY_WEAPON
	RTS

KEY_REPEAT:
	LDA	#16
	STA	KEYBOARD_REPEAT_TIMER	;reset kernal repeat timer (to prevent repeats) 
	LDA	KEYTIMER
	CMP	#0
	BNE	KEYR2
	LDA	KEYBOARD_KEY_PRESSED
	CMP	#64	;no key pressed
	BEQ	KEYR1
	LDA	#64	;clear LSTX register
	STA	KEYBOARD_KEY_PRESSED	;clear LSTX register
	LDA	#7
	STA	KEYTIMER
	RTS
KEYR1:	;No key pressed, reset all to defaults
	LDA	#0	
	STA	KEY_FAST
	LDA	#7
	STA	KEYTIMER
KEYR2:	RTS

;This routine handles things that are in common to
;all 4 directions of movement.
AFTER_MOVE:
	LDA	MOVE_RESULT
	CMP	#1
	BNE	AM01
	JSR	ANIMATE_PLAYER
	JSR	CACULATE_AND_REDRAW
AM01:	;now reset key-repeat rate
	LDA	KEY_FAST
	CMP	#0
	BNE	KEYR3
	;FIRST REPEAT
	LDA	#15
	STA	KEYTIMER
	INC	KEY_FAST
KEYR4:	JMP	MAIN_GAME_LOOP
KEYR3:	;SUBSEQUENT REPEATS
	LDA	#6
	STA	KEYTIMER
	JMP	MAIN_GAME_LOOP
KEY_FAST	!BYTE	0	;0=DEFAULT STATE

;This routine is invoked when the user presses S to search
;an object such as a crate, chair, or plant.
SEARCH_OBJECT:
	JSR	USER_SELECT_OBJECT
	LDA	#1
	STA	REDRAW_WINDOW
CHS1:	;first check of object is searchable
	JSR	CALC_COORDINATES
	JSR	GET_TILE_FROM_MAP
	LDX	TILE
	LDA	TILE_ATTRIB,X
	AND	#%01000000	;can search attribute
	CMP	#%01000000
	BEQ	CHS2
	LDA	#0
	STA	CURSOR_ON
	JMP	CHS3
CHS2:	;is the tile a crate?
	LDX	TILE
	CPX	#041	;BIG CRATE
	BEQ	CHS2B
	CPX	#045	;small CRATE
	BEQ	CHS2B
	CPX	#199	;"Pi" CRATE
	BEQ	CHS2B
	JMP	CHS2C
CHS2B:	LDA	DESTRUCT_PATH,X
	STA	TILE
	JSR	PLOT_TILE_TO_MAP
CHS2C:	;Now check if there is an object there.
	LDA	#0
	STA	SEARCHBAR
	LDA	#<MSG_SEARCHING
	STA	ZP0
	LDA	#>MSG_SEARCHING
	STA	ZP1
	JSR	PRINT_INFO
SOBJ1:	LDA	#18	;delay time between search periods
	STA	BGTIMER2
SOBJ2:	JSR	BACKGROUND_TASKS
	LDA	BGTIMER2
	CMP	#0
	BNE	SOBJ2
	LDX	SEARCHBAR
	LDA	#46	;PERIOD
	STA	SCREEN_RAM+$03C9,X
	INC	SEARCHBAR
	LDA	SEARCHBAR
	CMP	#8
	BNE	SOBJ1
	LDA	#0
	STA	CURSOR_ON
	JSR	DRAW_MAP_WINDOW		;ERASE THE CURSOR
	JSR	CALC_COORDINATES
	JSR	CHECK_FOR_HIDDEN_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	SOBJ5
CHS3:	LDA	#<MSG_NOTFOUND
	STA	ZP0
	LDA	#>MSG_NOTFOUND
	STA	ZP1
	JSR	PRINT_INFO
	RTS
SOBJ5:	LDX	UNIT_FIND
	LDA	UNIT_TYPE,X
	STA	TEMP_A		;store object type
	LDA	UNIT_A,X
	STA	TEMP_B		;store secondary info
	LDA	#0	;DELETE ITEM ONCE FOUND
	STA	UNIT_TYPE,X
	;***NOW PROCESS THE ITEM FOUND***
	LDX	#SOUND_ITEM_FOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDA	TEMP_A
	CMP	#128	;key
	BEQ	SOBJ10
	JMP	SOBJ15
SOBJ10:	LDA	TEMP_B		;WHICH SORT OF KEY?
	CMP	#00
	BNE	SOBJK1
	LDA	KEYS
	ORA	#%00000001	;Add spade key
	STA	KEYS
	JMP	SOBJ12
SOBJK1:	CMP	#01
	BNE	SOBJK2
	LDA	KEYS
	ORA	#%00000010	;Add heart key
	STA	KEYS
	JMP	SOBJ12
SOBJK2:	LDA	KEYS
	ORA	#%00000100	;Add star key
	STA	KEYS
SOBJ12:	LDA	#<MSG_FOUNDKEY
	STA	ZP0
	LDA	#>MSG_FOUNDKEY
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_KEYS
	RTS
SOBJ15:	CMP	#129	;TIME BOMB
	BNE	SOBJ17
	LDA	TEMP_B
	CLC
	ADC	INV_BOMBS
	STA	INV_BOMBS
	LDA	#<MSG_FOUNDBOMB
	STA	ZP0
	LDA	#>MSG_FOUNDBOMB
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
	RTS	
SOBJ17:	CMP	#130	;EMP	
	BNE	SOBJ20
	LDA	TEMP_B
	CLC
	ADC	INV_EMP
	STA	INV_EMP
	LDA	#<MSG_FOUNDEMP
	STA	ZP0
	LDA	#>MSG_FOUNDEMP
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
	RTS	
SOBJ20:	CMP	#131	;PISTOL
	BNE	SOBJ21
	LDA	TEMP_B
	CLC
	ADC	AMMO_PISTOL
	STA	AMMO_PISTOL
	BCC	SOBJ2A	;If we rolled over past 255
	LDA	#255	;set it to 255.
	STA	AMMO_PISTOL
SOBJ2A:	LDA	#<MSG_FOUNDGUN
	STA	ZP0
	LDA	#>MSG_FOUNDGUN
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_WEAPON	
SOBJ21:	CMP	#132	;PLASMA GUN
	BNE	SOBJ22
	LDA	TEMP_B
	CLC
	ADC	AMMO_PLASMA
	STA	AMMO_PLASMA
	LDA	#<MSG_FOUNDPLAS
	STA	ZP0
	LDA	#>MSG_FOUNDPLAS
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_WEAPON
SOBJ22:	CMP	#133	;MEDKIT
	BNE	SOBJ23
	LDA	TEMP_B
	CLC
	ADC	INV_MEDKIT
	STA	INV_MEDKIT
	LDA	#<MSG_FOUNDMED
	STA	ZP0
	LDA	#>MSG_FOUNDMED
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
SOBJ23:	CMP	#134	;MAGNET
	BNE	SOBJ99
	LDA	TEMP_B
	CLC
	ADC	INV_MAGNET
	STA	INV_MAGNET
	LDA	#<MSG_FOUNDMAG
	STA	ZP0
	LDA	#>MSG_FOUNDMAG
	STA	ZP1
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
SOBJ99:	;ADD CODE HERE FOR OTHER OBJECT TYPES
	RTS
SEARCHBAR	!BYTE 00	;to count how many periods to display.

;combines cursor location with window location
;to determine coordinates for MAP_X and MAP_Y
CALC_COORDINATES:
	LDA	CURSOR_X
	CLC
	ADC	MAP_WINDOW_X
	STA	MAP_X
	LDA	CURSOR_Y
	CLC
	ADC	MAP_WINDOW_Y
	STA	MAP_Y
	RTS

;This routine is called by routines such as the move, search,
;or use commands.  It displays a cursor and allows the user
;to pick a direction of an object.
USER_SELECT_OBJECT:
	LDX	#SOUND_BEEP
	JSR	PLAY_SOUND	;SOUND PLAY
	LDA	#5
	STA	CURSOR_X
	LDA	#3
	STA	CURSOR_Y
	LDA	#1
	STA	CURSOR_ON
	;JSR	DISPLAY_CURSOR
	;First ask user which object to move
MV01:	JSR	BACKGROUND_TASKS
	LDA	UNIT_TYPE
	CMP	#0	;Did player die wile moving something?
	BNE	MVCONT
	LDA	#0
	STA	CURSOR_ON
	RTS
MVCONT:	LDA	CONTROL
	CMP	#2
	BNE	MV01A
	JMP	MVSNES
MV01A:
	JSR GETKEY
	CMP	#$00
	BEQ	MV02
MV02:	CMP	#$1D	;CURSOR RIGHT
	BNE	MV03
MV00R:	INC	CURSOR_X
	LDA	#3
	STA	PLAYER_DIR
	RTS
MV03:	CMP	#$9D	;CURSOR LEFT
	BNE	MV04
MV00L:	DEC	CURSOR_X
	LDA	#2
	STA	PLAYER_DIR
	RTS	
MV04:	CMP	#$11	;CURSOR DOWN
	BNE	MV05
MV00D:	INC	CURSOR_Y
	LDA	#1
	STA	PLAYER_DIR
	RTS
MV05:	CMP	#$91	;CURSOR UP
	BNE	MV06
MV00U:	DEC	CURSOR_Y
	LDA	#0
	STA	PLAYER_DIR
	RTS
MV06:	CMP	KEY_MOVE_LEFT
	BNE	MV07
	JMP	MV00L
MV07:	CMP	KEY_MOVE_DOWN
	BNE	MV08
	JMP	MV00D
MV08:	CMP	KEY_MOVE_RIGHT
	BNE	MV09
	JMP	MV00R
MV09:	CMP	KEY_MOVE_UP
	BNE	MV0A
	JMP	MV00U
MV0A:	JMP	MV01

MVSNES:	;SNES controls for this routine
	JSR	SNES_CONTROLER_READ
	LDA	NEW_RIGHT
	CMP	#1
	BNE	MVS03
	INC	CURSOR_X
	LDA	#0
	STA	NEW_RIGHT
	LDA	#3
	STA	PLAYER_DIR
	RTS
MVS03:	LDA	NEW_LEFT
	CMP	#1
	BNE	MVS04
	DEC	CURSOR_X
	LDA	#0
	STA	NEW_LEFT
	LDA	#2
	STA	PLAYER_DIR
	RTS	
MVS04:	LDA	NEW_DOWN
	CMP	#1
	BNE	MVS05
	INC	CURSOR_Y
	LDA	#0
	STA	NEW_DOWN
	LDA	#1
	STA	PLAYER_DIR
	RTS
MVS05:	LDA	NEW_UP
	CMP	#1
	BNE	MVS06
	DEC	CURSOR_Y
	LDA	#0
	STA	NEW_UP
	LDA	#0
	STA	PLAYER_DIR
	RTS
MVS06:	JMP	MV01

MOVE_OBJECT:
	JSR	USER_SELECT_OBJECT
	LDA	UNIT
	;now test that object to see if it
	;is allowed to be moved.
MV10:	LDA	#0
	STA	CURSOR_ON
	;JSR	DISPLAY_CURSOR
	JSR	CALC_COORDINATES
	JSR	CHECK_FOR_HIDDEN_UNIT
	LDA	UNIT_FIND
	STA	MOVTEMP_U
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	TAY
	LDA	TILE_ATTRIB,Y
	AND	#%00000100		;can it be moved?	
	CMP	#%00000100		
	BEQ	MV11
	LDA	#<MSG_CANTMOVE
	STA	ZP0
	LDA	#>MSG_CANTMOVE
	STA	ZP1
	JSR	PRINT_INFO
	LDX	#SOUND_ERROR
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS
MV11:	LDA	TILE
	STA	MOVTEMP_O	;Store which tile it is we are moving
	LDA	MAP_X
	STA	MOVTEMP_X	;Store original location of object
	LDA	MAP_Y
	STA	MOVTEMP_Y
	LDA	#1
	STA	CURSOR_ON
	;JSR	DISPLAY_CURSOR
	LDX	#SOUND_BEEP
	JSR	PLAY_SOUND	;SOUND PLAY
	;NOW ASK THE USER WHICH DIRECTION TO MOVE IT TO
MV15:	JSR	BACKGROUND_TASKS
	LDA	UNIT_TYPE
	CMP	#0	;Did player die wile moving something?
	BNE	MVCONT2
	LDA	#0
	STA	CURSOR_ON
	RTS	
MVCONT2:	;which controller are we using?
	LDA	CONTROL
	CMP	#2
	BNE	MV15B
	JMP	SMV30

MV15B:	;keyboard control
	JSR GETKEY
	CMP	#$00
	BEQ	MV15
MV16:	CMP	#$1D	;CURSOR RIGHT
	BNE	MV17
	INC	CURSOR_X
	JMP	MV25
MV17:	CMP	#$9D	;CURSOR LEFT
	BNE	MV18
	DEC	CURSOR_X
	JMP	MV25	
MV18:	CMP	#$11	;CURSOR DOWN
	BNE	MV19
	INC	CURSOR_Y
	JMP	MV25
MV19:	CMP	#$91	;CURSOR UP
	BNE	MV20
	DEC	CURSOR_Y
	JMP	MV25
MV20:	CMP	KEY_MOVE_LEFT
	BNE	MV2A
	DEC	CURSOR_X
	JMP	MV25
MV2A:	CMP	KEY_MOVE_DOWN
	BNE	MV2B
	INC	CURSOR_Y
	JMP	MV25
MV2B:	CMP	KEY_MOVE_RIGHT
	BNE	MV2C
	INC	CURSOR_X
	JMP	MV25
MV2C:	CMP	KEY_MOVE_UP
	BNE	MV2D
	DEC	CURSOR_Y
	JMP	MV25
MV2D:	JMP	MV15	

SMV30:	;SNES controls
	JSR	SNES_CONTROLER_READ
	LDA	NEW_RIGHT
	CMP	#1
	BNE	SMV31
	INC	CURSOR_X
	LDA	#0
	STA	NEW_RIGHT
	JMP	MV25
SMV31:	LDA	NEW_LEFT
	CMP	#1
	BNE	SMV32
	DEC	CURSOR_X
	LDA	#0
	STA	NEW_LEFT
	JMP	MV25	
SMV32:	LDA	NEW_DOWN
	CMP	#1
	BNE	SMV33
	INC	CURSOR_Y
	LDA	#0
	STA	NEW_DOWN
	JMP	MV25
SMV33:	LDA	NEW_UP
	CMP	#1
	BNE	SMV34
	DEC	CURSOR_Y
	LDA	#0
	STA	NEW_UP
	JMP	MV25
SMV34:	JMP	MV15

	;NOW TEST TO SEE IF THAT SPOT IS OPEN
MV25:	LDA	#0
	STA	CURSOR_ON
	JSR	DRAW_MAP_WINDOW		;ERASE THE CURSOR
	LDA	CURSOR_X
	CLC
	ADC	MAP_WINDOW_X
	STA	MAP_X
	STA	MOVTEMP_UX
	LDA	CURSOR_Y
	CLC
	ADC	MAP_WINDOW_Y
	STA	MAP_Y
	STA	MOVTEMP_UY
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	TAY
	LDA	TILE_ATTRIB,Y
	AND	#%00100000		;is that spot available	
	CMP	#%00100000		;for something to move onto it?
	BEQ	MV30	
	JMP	MV3A				;If not, then exit routine.
MV30:	;Now scan for any units at that location:
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255			;255 means no unit found.
	BEQ	MV31
MV3A:	LDA	#<MSG_BLOCKED
	STA	ZP0
	LDA	#>MSG_BLOCKED
	STA	ZP1
	JSR	PRINT_INFO
	LDX	#SOUND_ERROR
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS
MV31:	LDX	#SOUND_MOVEOBJ
	JSR	PLAY_SOUND	;SOUND PLAY
	LDY	#0
	LDA	(ZP2),Y			;Grab current object
	STA	MOVTEMP_D
	LDA	MOVTEMP_O
	STA	(ZP2),Y			;replace with obect we are moving	
	LDA	MOVTEMP_X		;RETRIEVE original location of object
	STA	MAP_X
	LDA	MOVTEMP_Y
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDA	MOVTEMP_D
	CMP	#148		;trash compactor tile
	BNE	MV31A
	LDA	#09		;Floor tile
MV31A:	STA	(ZP2),Y			;Replace former location
	LDA	#1
	STA	REDRAW_WINDOW		;See the result
	LDA	MOVTEMP_U
	CMP	#255
	BNE	MV32
	RTS	
MV32:	LDX	MOVTEMP_U
	LDA	MOVTEMP_UX
	STA	UNIT_LOC_X,X
	LDA	MOVTEMP_UY
	STA	UNIT_LOC_Y,X
	RTS
MOVTEMP_O:	!BYTE 00	;origin tile
MOVTEMP_D:	!BYTE 00	;destination tile
MOVTEMP_X:	!BYTE 00	;x-coordinate
MOVTEMP_Y:	!BYTE 00	;y-coordinate
MOVTEMP_U:	!BYTE 00	;unit number (255=none)
MOVTEMP_UX	!BYTE 00
MOVTEMP_UY	!BYTE 00
CACULATE_AND_REDRAW:
	LDA	UNIT_LOC_X	;no index needed since it's player unit
	SEC
	SBC	#5
	STA	MAP_WINDOW_X
	LDA	UNIT_LOC_Y	;no index needed since it's player unit
	SEC
	SBC	#3
	STA	MAP_WINDOW_Y
	LDA	#1
	STA	REDRAW_WINDOW
	RTS

;This routine checks all units from 0 to 31 and figures out if it should be dislpayed
;on screen, and then grabs that unit's tile and stores it in the MAP_PRECALC array
;so that when the window is drawn, it does not have to search for units during the
;draw, speeding up the display routine.
MAP_PRE_CALCULATE:
	;CLEAR OLD BUFFER
	LDA	#0
	LDY	#0
PREC0:	STA	MAP_PRECALC,Y
	INY
	CPY	#77
	BNE	PREC0
	LDX	#0
	JMP PREC2	;Skip the check for unit 0 (player), always draw it
PREC1:	;CHECK THAT UNIT EXISTS
	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	PREC5
	;CHECK HORIZONTAL POSITION
	LDA	UNIT_LOC_X,X
	CMP	MAP_WINDOW_X
	BCC	PREC5
	LDA	MAP_WINDOW_X
	CLC
	ADC	#10
	CMP	UNIT_LOC_X,X
	BCC	PREC5
	;NOW CHECK VERTICAL
	LDA	UNIT_LOC_Y,X
	CMP	MAP_WINDOW_Y
	BCC	PREC5
	LDA	MAP_WINDOW_Y
	CLC
	ADC	#6
	CMP	UNIT_LOC_Y,X
	BCC	PREC5
	;Unit found in map window, now add that unit's
	;tile to the precalc map.
PREC2:	LDA	UNIT_LOC_Y,X
	SEC
	SBC	MAP_WINDOW_Y
	TAY
	LDA	UNIT_LOC_X,X
	SEC
	SBC	MAP_WINDOW_X
	CLC
	ADC	PRECALC_ROWS,Y	
	TAY
	LDA	UNIT_TILE,X
	CMP	#130	;is it a bomb
	BEQ	PREC6
	CMP	#134	;is it a magnet?
	BEQ	PREC6
PREC4:	STA	MAP_PRECALC,Y
PREC5:	;continue search
	INX	
	CPX	#32
	BNE	PREC1
	RTS
PREC6:	;What to do in case of bomb or magnet that should
	;go underneath the unit or robot.
	LDA	MAP_PRECALC,Y
	CMP	#0
	BNE	PREC5
	LDA	UNIT_TILE,X
	JMP	PREC4		

PRECALC_ROWS:	!BYTE	0,11,22,33,44,55,66

;This routine is where the MAP is displayed on the screen
;This is a temporary routine, taken from the map editor.
DRAW_MAP_WINDOW:
	JSR	MAP_PRE_CALCULATE
	LDA	#0
	STA	REDRAW_WINDOW
	STA	TEMP_X
	STA	TEMP_Y
	STA	PRECALC_COUNT
	
	;LDA #$44
	;STA BORDER_COLOR
	
	LDA MAP_OPEN
	CMP #0
	BEQ DM01
	RTS
DM01:	;FIRST CALCULATE WHERE THE BYTE IS STORED IN THE MAP
	LDY	#0
	LDA	TEMP_Y
	CLC
	ADC	MAP_WINDOW_Y	
	ROR
	PHP
	CLC
	ADC	#>MAP
	STA	ZP3	;HIGH BYTE OF MAP SOURCE
	LDA	#$0
	PLP
	ROR
	CLC
	ADC	TEMP_X
	ADC	MAP_WINDOW_X
	STA	ZP2	;LOW BYTE OF MAP SOURCE
	LDA	(ZP2),Y
	STA	TILE
	;NOW FIGURE OUT WHERE TO PLACE IT ON SCREEN.
	LDX	TEMP_Y
	LDA	MAP_CHART_L,X
	STA	ZP0	;LOW BYTE OF SCREEN AREA
	LDA	MAP_CHART_H,X
	STA	ZP1	;HIGH BYTE OF SCREEN AREA
	LDA	TEMP_X
	ASL	;MULTIPLY BY 2
	CLC
	ADC	TEMP_X	;ADD ANOTHER TO MAKE X3
	ADC	ZP0
	STA	ZP0
	LDA	ZP1
	ADC	#00	;CARRY FLAG
	STA	ZP1
	JSR	PLOT_TILE
	;now check for sprites in this location
	LDY	PRECALC_COUNT
	LDA	MAP_PRECALC,Y
	CMP	#00
	BEQ	DM02
	STA	TILE
	LDX	TEMP_Y
	LDA	MAP_CHART_L,X
	STA	ZP0	;LOW BYTE OF SCREEN AREA
	LDA	MAP_CHART_H,X
	STA	ZP1	;HIGH BYTE OF SCREEN AREA
	LDA	TEMP_X
	ASL	;MULTIPLY BY 2
	CLC
	ADC	TEMP_X	;ADD ANOTHER TO MAKE X3
	ADC	ZP0
	STA	ZP0
	LDA	ZP1
	ADC	#00	;CARRY FLAG
	STA	ZP1
	JSR	PLOT_TRANSPARENT_TILE
DM02:	INC	TEMP_X
	INC	PRECALC_COUNT
	LDA	TEMP_X
	CMP	#11
	BNE	DM01
DM04:	LDA	#0
	STA	TEMP_X
	INC	TEMP_Y
	LDA	TEMP_Y
	CMP	#7
	BEQ	DM10
	JMP	DM01
DM10:	;JSR	DISPLAY_CURSOR

;LDA #$71
;STA BORDER_COLOR

	RTS
	
;This routine plots a 3x3 tile from the tile database anywhere
;on screen.  But first you must define the tile number in the
;TILE variable, as well as the starting screen address must
;be defined in ZP0.
PLOT_TILE:
	LDA	ZP0	;Grab the starting address, and adjust it for
	STA	ZP2	;the color RAM before we get started.
	LDA	ZP1
	STA	ZP3
	LDX	TILE
	;DRAW THE TOP 3 CHARACTERS
	LDA	TILE_DATA_TL,X
	LDY	#0
	STA	(ZP0),Y
	LDA	TILE_DATA_TM,X
	INY
	STA	(ZP0),Y	
	LDA	TILE_DATA_TR,X
	INY
	STA	(ZP0),Y	
	;MOVE DOWN TO NEXT LINE
	LDY	#40
	;DRAW THE MIDDLE 3 CHARACTERS
	LDA	TILE_DATA_ML,X
	STA	(ZP0),Y
	LDA	TILE_DATA_MM,X
	INY
	STA	(ZP0),Y	
	LDA	TILE_DATA_MR,X
	INY
	STA	(ZP0),Y	
	;MOVE DOWN TO NEXT LINE
	LDY	#80
	;DRAW THE BOTTOM 3 CHARACTERS
	LDA	TILE_DATA_BL,X
	STA	(ZP0),Y
	LDA	TILE_DATA_BM,X
	INY
	STA	(ZP0),Y	
	LDA	TILE_DATA_BR,X
	INY
	STA	(ZP0),Y
	;NOW DO THE COLOR
PT01:	LDA	ZP3
	SEC
	SBC	#$04	;adjust to color RAM area by SUBTRACTING $0400	
	STA	ZP3
	;DRAW THE TOP 3 COLORS
	LDA	TILE_COLOR_TL,X
	LDY	#0
	STA	(ZP2),Y
	LDA	TILE_COLOR_TM,X
	INY
	STA	(ZP2),Y	
	LDA	TILE_COLOR_TR,X
	INY
	STA	(ZP2),Y	
	;MOVE DOWN TO NEXT LINE
	LDY	#40
	;DRAW THE MIDDLE 3 COLORS
	LDA	TILE_COLOR_ML,X
	STA	(ZP2),Y
	LDA	TILE_COLOR_MM,X
	INY
	STA	(ZP2),Y	
	LDA	TILE_COLOR_MR,X
	INY
	STA	(ZP2),Y	
	;MOVE DOWN TO NEXT LINE
	LDY	#80	
	;DRAW THE BOTTOM 3 COLORS
	LDA	TILE_COLOR_BL,X
	STA	(ZP2),Y
	LDA	TILE_COLOR_BM,X
	INY
	STA	(ZP2),Y	
	LDA	TILE_COLOR_BR,X
	INY
	STA	(ZP2),Y	
	RTS	

;This routine plots a transparent tile from the tile database
;anywhere on screen.  But first you must define the tile number
;in the TILE variable, as well as the starting screen address must
;be defined in ZP0.  Also, this routine is slower than the usual
;tile routine, so is only used for sprites.  The ":" character ($3A)
;is not drawn.
PLOT_TRANSPARENT_TILE:
	LDA	ZP0	;Grab the starting address, and adjust it for
	STA	ZP2	;the color RAM before we get started.
	LDA	ZP1
	STA	ZP3
	LDX	TILE
	;DRAW THE TOP 3 CHARACTERS
	LDA	TILE_DATA_TL,X
	LDY	#0
	CMP	#$3A
	BEQ	PTT01
	STA	(ZP0),Y
PTT01:	LDA	TILE_DATA_TM,X
	INY
	CMP	#$3A
	BEQ	PTT02
	STA	(ZP0),Y	
PTT02:	LDA	TILE_DATA_TR,X
	INY
	CMP	#$3A
	BEQ	PTT03
	STA	(ZP0),Y	
	;MOVE DOWN TO NEXT LINE
PTT03:	LDY	#40
	;DRAW THE MIDDLE 3 CHARACTERS
	LDA	TILE_DATA_ML,X
	CMP	#$3A
	BEQ	PTT04
	STA	(ZP0),Y
PTT04:	LDA	TILE_DATA_MM,X
	INY
	CMP	#$3A
	BEQ	PTT05
	STA	(ZP0),Y	
PTT05:	LDA	TILE_DATA_MR,X
	INY
	CMP	#$3A
	BEQ	PTT06
	STA	(ZP0),Y	
	;MOVE DOWN TO NEXT LINE
PTT06:	LDY	#80
	;DRAW THE BOTTOM 3 CHARACTERS
	LDA	TILE_DATA_BL,X
	CMP	#$3A
	BEQ	PTT07
	STA	(ZP0),Y
PTT07:	LDA	TILE_DATA_BM,X
	INY
	CMP	#$3A
	BEQ	PTT08
	STA	(ZP0),Y	
PTT08:	LDA	TILE_DATA_BR,X
	INY
	CMP	#$3A
	BEQ	PTT09
	STA	(ZP0),Y	
PTT09:		;NOW DO THE COLOR
	LDA	ZP3
	SEC
	SBC	#$04	;adjust to color RAM area by SUBTRACTING $0400	
	STA	ZP3
	;DRAW THE TOP 3 COLORS
	LDA	TILE_COLOR_TL,X
	LDY	#0
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT10
	STA	(ZP2),Y
PTT10:	LDA	TILE_COLOR_TM,X
	INY
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT11
	STA	(ZP2),Y	
PTT11:	LDA	TILE_COLOR_TR,X
	INY
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT12
	STA	(ZP2),Y	
	;MOVE DOWN TO NEXT LINE
PTT12:	LDY	#40
	;DRAW THE MIDDLE 3 COLORS
	LDA	TILE_COLOR_ML,X
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT13
	STA	(ZP2),Y
PTT13:	LDA	TILE_COLOR_MM,X
	INY
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT14
	STA	(ZP2),Y	
PTT14:	LDA	TILE_COLOR_MR,X
	INY
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT15
	STA	(ZP2),Y	
	;MOVE DOWN TO NEXT LINE
PTT15:	LDY	#80
	;DRAW THE BOTTOM 3 COLORS
	LDA	TILE_COLOR_BL,X
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT16
	STA	(ZP2),Y
PTT16:	LDA	TILE_COLOR_BM,X
	INY
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT17
	STA	(ZP2),Y	
PTT17:	LDA	TILE_COLOR_BR,X
	INY
	CMP	#$00	;If it is black, don't draw it.
	BEQ	PTT18
	STA	(ZP2),Y	
PTT18:	RTS	

DISPLAY_CURSOR:	;Called from IRQ routine to update the cursor
	LDX	CURSOR_Y
	LDA	MAP_CHART_L,X
	STA	ZIRQ0	;LOW BYTE OF SCREEN AREA
	LDA	MAP_CHART_H,X
	STA	ZIRQ1	;HIGH BYTE OF SCREEN AREA
	LDA	CURSOR_X
	ASL	;MULTIPLY BY 2
	CLC
	ADC	CURSOR_X	;ADD ANOTHER TO MAKE X3
	ADC	ZIRQ0
	STA	ZIRQ0
	LDA	ZIRQ1
	ADC	#00	;CARRY FLAG
	STA	ZIRQ1
	LDY	#00
	LDA	#$70
	STA	(ZIRQ0),Y
	INY
	INY	
	LDA	#$6E
	STA	(ZIRQ0),Y
	LDY	#80
	LDA	#$6D
	STA	(ZIRQ0),Y
	INY
	INY	
	LDA	#$7D
	STA	(ZIRQ0),Y
	; Cursor color
	LDA	ZIRQ1
	SEC
	SBC #$04	;Subtract to color ram
	STA	ZIRQ1
	LDY	#00
	LDA ANIM_COLOR
	STA	(ZIRQ0),Y
	INY
	INY	
	STA	(ZIRQ0),Y
	LDY	#80
	STA	(ZIRQ0),Y
	INY
	INY	
	STA	(ZIRQ0),Y
	RTS

;This routine checks to see if UNIT is occupying any space
;that is currently visible in the window.  If so, the
;flag for redrawing the window will be set.
CHECK_FOR_WINDOW_REDRAW:
	LDX	UNIT
	;FIRST CHECK HORIZONTAL
	LDA	UNIT_LOC_X,X
	CMP	MAP_WINDOW_X
	BCC	CFR1
	LDA	MAP_WINDOW_X
	CLC
	ADC	#10
	CMP	UNIT_LOC_X,X
	BCC	CFR1
	;NOW CHECK VERTICAL
	LDA	UNIT_LOC_Y,X
	CMP	MAP_WINDOW_Y
	BCC	CFR1
	LDA	MAP_WINDOW_Y
	CLC
	ADC	#6
	CMP	UNIT_LOC_Y,X
	BCC	CFR1
	LDA	#1
	STA	REDRAW_WINDOW
CFR1:	RTS

DECWRITE:
	LDA	#$00
	STA	SCREENPOS
	LDA	DECNUM
	LDX 	#2
	LDY 	#$4C
DEC1	STY 	DECB
	LSR
DEC2	ROL
	BCS 	DEC3
	CMP	DECA,X
	BCC 	DEC4
DEC3	SBC 	DECA,X
	SEC
DEC4	ROL 	DECB
	BCC 	DEC2
	STA	DECTEMP
	LDA 	DECB
	LDY	SCREENPOS
	STA	(ZP0),Y
	INC	SCREENPOS
	LDA	DECTEMP
	LDY 	#$13
	DEX
	BPL 	DEC1
	RTS
DECA		!BYTE  	128,160,200
DECB		!BYTE  	1
SCREENPOS	!BYTE	$00
DECTEMP		!BYTE	$00

;Displays loading message for map.
DISPLAY_LOAD_MESSAGE2:
	LDY	#0
DLM2:	LDA	LOAD_MSG2,Y
	STA	SCREEN_RAM+$0190,Y
	INY
	CPY	#12
	BNE	DLM2
	JSR	CALC_MAP_NAME
DLM3:	LDA	(ZP0),Y
	STA	SCREEN_RAM+$019C,Y
	INY
	CPY	#16
	BNE	DLM3	
	RTS
LOAD_MSG2:	!SCR"loading map:"

GREEN_SCREEN:
	LDA	#$5A	;GREEN	
	LDX	#$00
CS03:	STA	COLOR_RAM,X
	STA	COLOR_RAM+$0100,X
	STA	COLOR_RAM+$0200,X
	INX
	CPX	#$00
	BNE	CS03
CS04:
	STA	COLOR_RAM+$0300,X
	INX
	CPX	#$E8
	BNE	CS04	
	RTS

DISPLAY_GAME_SCREEN:
	;SET SOURCE
	LDA	#<SCR_TEXT
	STA	ZP0
	LDA	#>SCR_TEXT
	STA	ZP1
	;SET DESTINATION
	LDA	#<SCREEN_RAM
	STA	ZP2
	LDA	#>SCREEN_RAM
	STA	ZP3
	;SET END
	LDA	#>SCREEN_RAM+$0300
	STA	DGS5+1
	LDA	#$E7
	STA	DGS6+1
	JSR	DECOMPRESS_SCREEN
	;SET SOURCE
	LDA	#<SCR_COLOR
	STA	ZP0
	LDA	#>SCR_COLOR
	STA	ZP1
	;SET DESTINATION
	LDA	#<COLOR_RAM
	STA	ZP2
	LDA	#>COLOR_RAM
	STA	ZP3
	;SET END
	LDA	#>COLOR_RAM+$0300
	STA	DGS5+1
	LDA	#$E7
	STA	DGS6+1
	JSR	DECOMPRESS_SCREEN
	RTS


;DISPLAY_INTRO_SCREEN:
;	;SET SOURCE
;	LDA	#<INTRO_TEXT
;	STA	ZP0
;	LDA	#>INTRO_TEXT
;	STA	ZP1
;	;SET DESTINATION
;	LDA	#<SCREEN_RAM
;	STA	ZP2
;	LDA	#>SCREEN_RAM
;	STA	ZP3
;	;SET END
;	LDA	#>SCREEN_RAM+$0300
;	STA	DGS5+1
;	LDA	#$E7
;	STA	DGS6+1
;	JSR	DECOMPRESS_SCREEN
;	;SET SOURCE
;	LDA	#<INTRO_COLOR
;	STA	ZP0
;	LDA	#>INTRO_COLOR
;	STA	ZP1
;	;SET DESTINATION
;	LDA	#<COLOR_RAM
;	STA	ZP2
;	LDA	#>COLOR_RAM
;	STA	ZP3
;	;SET END
;	LDA	#>COLOR_RAM+$0300
;	STA	DGS5+1
;	LDA	#$E7
;	STA	DGS6+1
;	JSR	DECOMPRESS_SCREEN
;	RTS

DISPLAY_ENDGAME_SCREEN:
	JSR	GREEN_SCREEN	;set monochrome screen for now.
	;SET SOURCE
	LDA	#<SCR_ENDGAME
	STA	ZP0
	LDA	#>SCR_ENDGAME
	STA	ZP1
	;SET DESTINATION
	LDA	#<SCREEN_RAM
	STA	ZP2
	LDA	#>SCREEN_RAM
	STA	ZP3
	;SET END
	LDA	#>SCREEN_RAM+$0300
	STA	DGS5+1
	LDA	#$E7
	STA	DGS6+1
	JSR	DECOMPRESS_SCREEN
	;display map name
	JSR	CALC_MAP_NAME
DEG3:	LDA	(ZP0),Y
	STA	SCREEN_RAM+$012E,Y
	INY
	CPY	#16
	BNE	DEG3	
	;display elapsed time
	LDA	HOURS
	STA	DECNUM
	LDA	#>SCREEN_RAM+$0100
	STA	ZP1
	LDA	#$7D
	STA	ZP0
	JSR	DECWRITE
	LDA	MINUTES
	STA	DECNUM
	LDA	#>SCREEN_RAM+$0100
	STA	ZP1
	LDA	#$80
	STA	ZP0
	JSR	DECWRITE
	LDA	SECONDS
	STA	DECNUM
	LDA	#>SCREEN_RAM+$0100
	STA	ZP1
	LDA	#$83
	STA	ZP0
	JSR	DECWRITE
	LDA	#32	;SPACE
	STA	SCREEN_RAM+$017D
	LDA	#58	;COLON
	STA	SCREEN_RAM+$0180
	STA	SCREEN_RAM+$0183
	;count robots remaining
	LDX	#1
	LDA	#0
	STA	DECNUM
DEG7:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	DEG8
	INC	DECNUM
DEG8:	INX
	CPX	#28
	BNE	DEG7
	LDA	#>SCREEN_RAM+$0100
	STA	ZP1
	LDA	#$CE
	STA	ZP0
	JSR	DECWRITE
	;Count secrets remaining
	LDA	#0
	STA	DECNUM
	LDX	#48
DEG9:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	DEG10
	INC	DECNUM
DEG10:	INX
	CPX	#64
	BNE	DEG9
	LDA	#>SCREEN_RAM+$0200
	STA	ZP1
	LDA	#$1E
	STA	ZP0
	JSR	DECWRITE
	;display difficulty level
	LDY	DIFF_LEVEL
	LDA	DIFF_LEVEL_LEN,Y
	TAY	
	LDX	#0
DEG11:	LDA	DIFF_LEVEL_WORDS,Y
	CMP	#0
	BEQ	DEG12
	STA	SCREEN_RAM+$026E,X
	INY
	INX
	JMP	DEG11
DEG12:	RTS

DIFF_LEVEL_WORDS:
	!SCR "easy",0,"normal",0,"hard",0
DIFF_LEVEL_LEN:
	!BYTE 0,5,12

DECOMPRESS_SCREEN:
	LDY	#00
DGS1:	LDA	(ZP0),Y
	CMP	#96	;REPEAT FLAG
	BEQ	DGS10	
DGS2:	STA	(ZP2),Y
	;CHECK TO SEE IF WE REACHED $83E7 YET.	
DGS4:	LDA	ZP3
DGS5:	CMP	#$83	;SELF MODIFYING CODE
	BNE	DGS3
	LDA	ZP2
DGS6:	CMP	#$E7	;SELF MODIFYING CODE
	BNE	DGS3
	RTS
DGS3:	JSR	INC_SOURCE
	JSR	INC_DEST
	JMP	DGS1
DGS10:	;REPEAT CODE
	JSR	INC_SOURCE
	LDA	(ZP0),Y
	STA	RPT
	JSR	INC_SOURCE
	LDA	(ZP0),Y
	TAX
DGS11:	LDA	RPT
	STA	(ZP2),Y
	JSR	INC_DEST
	DEX
	CPX	#$FF
	BNE	DGS11
	LDA	ZP2
	SEC
	SBC	#01
	STA	ZP2
	LDA	ZP3
	SBC	#00
	STA	ZP3
	JMP	DGS4	
INC_SOURCE:
	LDA	ZP0
	CLC
	ADC	#01
	STA	ZP0
	LDA	ZP1
	ADC	#00
	STA	ZP1
	RTS
INC_DEST:
	LDA	ZP2
	CLC
	ADC	#01
	STA	ZP2
	LDA	ZP3
	ADC	#00
	STA	ZP3
	RTS
RPT	!BYTE 00	;repeat value

DISPLAY_PLAYER_HEALTH:
	LDA	UNIT_HEALTH	;No index needed because it is the player
	LSR			;divide by two
	STA	TEMP_A
	LDY	#00
DPH01:	CPY	TEMP_A
	BEQ	DPH02	
	LDA	#$66		;GRAY BLOCK
	STA	SCREEN_RAM+$03BA,Y
	STY ZP0			;Store position of last health bar for coloring
	INY	
	JMP	DPH01	
DPH02:	LDA	UNIT_HEALTH
	AND	#%00000001
	CMP	#%00000001
	BNE	DPH03
	LDA	#$5C		;HALF GRAY BLOCK
	STA	SCREEN_RAM+$03BA,Y
	STY ZP0			;Store position of last health bar for coloring
	INY
DPH03:	CPY	#6
	BEQ	DPH04
	LDA	#$20		;SPACE
	STA	SCREEN_RAM+$03BA,Y	
	INY
	JMP	DPH03
	;Set color of health bar
DPH04:	LDY ZP0
	LDA COLOR_RAM+$03E2,Y
	LDY #00
DPH05:	STA COLOR_RAM+$03BA,Y
	INY
	CPY #6
	BNE DPH05
	RTS

CYCLE_ITEM:
	LDX	#SOUND_CYCLE_ITEM
	JSR	PLAY_SOUND	;SOUND PLAY
	LDA	#20
	STA	KEYTIMER
	INC	SELECTED_ITEM
	LDA	SELECTED_ITEM
	CMP	#5
	BEQ	CYIT1
	JMP	DISPLAY_ITEM
CYIT1:	LDA	#0
	STA	SELECTED_ITEM
	JMP	DISPLAY_ITEM

;Display the currently selected item
DISPLAY_ITEM:
	JSR	PRESELECT_ITEM
DSIT00:
	LDX	SELECTED_ITEM
	CPX	#0
	BNE	DSIT01
	RTS					;return if no items to show
DSIT01:
	LDA INVENTORY,X		;Load the selected item
	CMP #0				;Did we run out of inventory on this item?
	BNE DSIT02			;Branch if we have inventory for this item
	INX
	CPX #5
	BCC DSIT01			;Loop while X < 5
	LDA #0				;Ran out of inventory to check, set selected_item to zero and return
	STA SELECTED_ITEM
	JSR PRESELECT_ITEM
	JMP DISPLAY_ITEM
DSIT02:					;Save and Display selected item
	STX SELECTED_ITEM
	LDA INVENTORY_GFX_L-$0001,X
	STA ZP2
	LDA INVENTORY_GFX_H-$0001,X
	STA ZP3
	LDA INVENTORY_COLOR_L-$0001,X
	STA ZP4
	LDA INVENTORY_COLOR_H-$0001,X
	STA ZP5
	LDY #0
DSIT03:					;Copy item graphic into character tiles
	LDA (ZP2),Y
	STA CHAR_RAM+$0780,Y
	INY
	CPY #128
	BNE DSIT03			;Loop until Y = 128
	LDX #0
	LDY #0
	LDA #4
	STA DSIT05+$0001	;Store initial self-modifying loop compare value
DSIT04:					;Copy color into color ram for the item
	LDA (ZP4),Y
	STA COLOR_RAM+$0163,X
	INY
	INX
DSIT05:	CPX #4			;SELF MODIFYING COMPARE VALUE, will increase by 40 each loop pass, to go to the next row of the screen
	BNE DSIT04
	TXA					;Add 40 to the self-modifying compare value
	CLC
	ADC #40
	STA DSIT05+$0001
	SEC
	SBC #4
	TAX
	CPX #160
	BCC DSIT04			;Loop until we have done 4 rows of color for the item
	LDX SELECTED_ITEM	;Write the number showing how many of this item is in the player's inventory
	LDA INVENTORY,X
	STA DECNUM
	LDA #$05
	STA ZP0
	LDA #>SCREEN_RAM+$0200
	STA ZP1
	JMP DECWRITE

;This routine checks to see if currently selected
;item is zero.  And if it is, then it checks inventories
;of other items to decide which item to automatically
;select for the user.
PRESELECT_ITEM:
	LDA	SELECTED_ITEM
	CMP	#0		;If item already selected, return
	BNE	PRSI04
	TAX
PRSI01:
	INX
	CPX #5				;Check if we're beyond the inventory items and need to exit loop
	BEQ PRSI02
	LDA INVENTORY,X		;Check if INV_BOMBS, INV_EMP, INV_MEDKIT, INV_MAGNET selected
	CMP #0
	BEQ PRSI01
	STX SELECTED_ITEM	;Found an item with inventory, select it
	RTS
PRSI02:					;Nothing found in inventory at this point, so SELECTED_ITEM to zero
	STA SELECTED_ITEM
	TAY					;Display blank item
PRSI03:
	STA CHAR_RAM+$0780,Y
	INY
	CPY #128
	BNE PRSI03
	LDA #32
	STA SCREEN_RAM+$0205
	STA SCREEN_RAM+$0206
	STA SCREEN_RAM+$0207
PRSI04:
	RTS

CYCLE_WEAPON:
	LDX	#SOUND_CYCLE_WEAPON
	JSR	PLAY_SOUND	;SOUND PLAY
	LDA	#20
	STA	KEYTIMER
	INC	SELECTED_WEAPON
	LDA	SELECTED_WEAPON
	CMP	#2
	BNE	CYWE1
	JMP	DISPLAY_WEAPON
CYWE1:	LDA	#0
	STA	SELECTED_WEAPON
	JMP	DISPLAY_WEAPON

DISPLAY_WEAPON:
	JSR	PRESELECT_WEAPON
	LDA	SELECTED_WEAPON
	CMP	#0	;no weapon to show
	BNE	DSWP01
	RTS
DSWP01:	CMP	#1	;PISTOL
	BNE	DSWP03
	LDA	AMMO_PISTOL
	CMP	#0	;did we run out?
	BNE	DSWP02
	LDA	#0
	STA	SELECTED_WEAPON
	JMP	DISPLAY_WEAPON
DSWP02:	JSR	DISPLAY_PISTOL
	RTS
DSWP03:	CMP	#2	;PLASMA GUN
	BNE	DSWP05
	LDA	AMMO_PLASMA
	CMP	#0	;did we run out?
	BNE	DSWP04
	LDA	#0
	STA	SELECTED_WEAPON
	JMP	DISPLAY_WEAPON
DSWP04:	JSR	DISPLAY_PLASMA_GUN
	RTS
DSWP05:	LDA	#0
	STA	SELECTED_WEAPON	;should never happen
	JMP	DISPLAY_WEAPON
	
;This routine checks to see if currently selected
;weapon is zero.  And if it is, then it checks inventories
;of other weapons to decide which item to automatically
;select for the user.
PRESELECT_WEAPON:
	LDA	SELECTED_WEAPON
	CMP	#0		;If item already selected, return
	BEQ	PRSW01
	RTS	
PRSW01:	LDA	AMMO_PISTOL
	CMP	#0
	BEQ	PRSW02
	LDA	#1	;PISTOL
	STA	SELECTED_WEAPON
	RTS
PRSW02:	LDA	AMMO_PLASMA
	CMP	#0
	BEQ	PRSW04
	LDA	#2	;PLASMAGUN
	STA	SELECTED_WEAPON
	RTS
PRSW04:	;Nothing found in inventory at this point, so set
	;selected-item to zero.
	LDA	#0	;nothing in inventory
	STA	SELECTED_WEAPON
	JSR	DISPLAY_BLANK_WEAPON
	RTS

DISPLAY_PLASMA_GUN:
	LDY	#0
DW1:
	LDA	WEAPONGFX,Y
	STA	CHAR_RAM+$0720,Y
	INY
	CPY	#96
	BNE	DW1
	LDY #0
DW2:
	LDA WEAPONCOLOR,Y
	STA COLOR_RAM+$0072,Y
	INY
	CPY #6
	BNE DW2
	LDX #0
DW3:
	LDA WEAPONCOLOR,Y
	STA COLOR_RAM+$009A,X
	INY
	INX
	CPX #6
	BNE DW3
	LDA	AMMO_PLASMA
	STA	DECNUM
	LDA	#$ED
	STA	ZP0
	LDA	#>SCREEN_RAM
	STA	ZP1
	JSR	DECWRITE	
	RTS

DISPLAY_PISTOL:
	LDY	#0
DP1:
	LDA	PISTOLGFX,Y
	STA	CHAR_RAM+$0720,Y
	INY
	CPY	#96
	BNE	DP1
	LDY #0
DP2:
	LDA PISTOLCOLOR,Y
	STA COLOR_RAM+$0072,Y
	INY
	CPY #6
	BNE DP2
	LDX #0
DP3:
	LDA PISTOLCOLOR,Y
	STA COLOR_RAM+$009A,X
	INY
	INX
	CPX #6
	BNE DP3
	LDA	AMMO_PISTOL
	STA	DECNUM
	LDA	#$ED
	STA	ZP0
	LDA	#>SCREEN_RAM
	STA	ZP1
	JSR	DECWRITE	
	RTS

DISPLAY_BLANK_WEAPON:
	LDA	#0
	LDY #0
DBW1:	
	STA CHAR_RAM+$0720,Y
	INY
	CPY #96
	BNE DBW1
	LDA #32
	STA SCREEN_RAM+$00ED;
	STA SCREEN_RAM+$00EE;
	STA SCREEN_RAM+$00EF;
	RTS	
	
DISPLAY_KEYS:
	LDA	#32
	LDX #6
DKS0:	DEX
	STA	SCREEN_RAM+$027A,X	;ERASE ALL 3 SPOTS
	STA	SCREEN_RAM+$02A2,X
	BNE DKS0
	LDA	KEYS
	AND	#%00000001
	CMP	#%00000001	;Spade key
	BNE	DKS1
	LDA #$41		;Spade tile (drawing offset not needed for this one, because X is already zero)
	JSR	DISPLAY_KEY_TILES
DKS1:	LDA	KEYS
	AND	#%00000010
	CMP	#%00000010	;heart key
	BNE	DKS2
	LDA #$53		;heart tile
	LDX #2			;drawing offset
	JSR DISPLAY_KEY_TILES
DKS2:	LDA	KEYS
	AND	#%00000100
	CMP	#%00000100	;star key
	BNE	DKS3
	LDA #$2A		;star tile
	LDX #4			;drawing offset
	JSR DISPLAY_KEY_TILES
DKS3:	RTS

;Displays the tiles for a key. The accumulator should contain the tile for the key.
;X should contain the offset to draw at
DISPLAY_KEY_TILES
	STA	SCREEN_RAM+$02A2,X	;Store tile passed in the Accumulator
	LDA	#$63
	STA	SCREEN_RAM+$027A,X
	LDA	#$4D
	STA	SCREEN_RAM+$027B,X
	LDA	#$67
	STA	SCREEN_RAM+$02A3,X
	RTS

GAME_OVER:
	;stop game clock
	LDA	#0
	STA	CLOCK_ACTIVE
	;Did player die or win?
	LDA	UNIT_TYPE
	CMP	#0
	BNE	GOM0
	LDA #4
	STA PLAYER_DIR		;Player direction #4 is death
	STA PLAYER_ANI		;Storing a non-zero value for the animation will make it change to a zero when we animate
	;Change player color to red
	LDA #$22
	JSR PLAYER_COLOR
	JSR ANIMATE_PLAYER
	LDA	#100
	STA	KEYTIMER
GOM0:	JSR	BACKGROUND_TASKS
	LDA	KEYTIMER
	CMP	#0
	BNE	GOM0
	;stop screen shake
	LDA	#0
	STA	SCREEN_SHAKE
	LDA	$FF07
	AND #%11111000
	STA	$FF07		; Reset screen scroll position after shake
	;display game over message
	LDX	#0
GOM1:	LDA	GAMEOVER1,X
	STA	SCREEN_RAM+$0173,X
	LDA	GAMEOVER2,X
	STA	SCREEN_RAM+$019B,X
	LDA	GAMEOVER3,X
	STA	SCREEN_RAM+$01C3,X
GOM1A:	INX
	CPX	#11
	BNE	GOM1
	LDA	#100
	STA	KEYTIMER
GOM2:	JSR	ANIMATE_GAMEOVER
	LDA	KEYTIMER
	CMP	#0
	BNE	GOM2
	JSR CLEAR_KEY_BUFFER
GOM3:	JSR	ANIMATE_GAMEOVER
	JSR GETKEY
	CMP	#$00
	BEQ	GOM3
GOM4:
	JSR CLEAR_KEY_BUFFER
	;LDX	#SOUND_BEEP
	;JSR	PLAY_SOUND	;SOUND PLAY
	JSR	DISPLAY_ENDGAME_SCREEN
	JSR	PLAY_GAME_OVER_MUSIC
	JSR	DISPLAY_WIN_LOSE
	;Wait for keypress
GOM5:	
	JSR GETKEY
	CMP	#$00
	BEQ	GOM5
	LDA	#0
	STA	$009E	;CLEAR KEYBOARD BUFFER	
	JMP	INTRO_SCREEN
ANIMATE_GAMEOVER:
	LDX	#0
	LDA	ANIM_COLOR	;CURSOR Animation COLOR
ANGO:	
	STA	COLOR_RAM+$0173,X
	STA	COLOR_RAM+$019B,X
	STA	COLOR_RAM+$01C3,X
	INX
	CPX	#11
	BNE	ANGO
	RTS

GAMEOVER1:	!BYTE	$70,$40,$40,$40,$40,$40,$40,$40,$40,$40,$6e
GAMEOVER2:	!BYTE	$5d,$07,$01,$0d,$05,$20,$0f,$16,$05,$12,$5d
GAMEOVER3:	!BYTE	$6d,$40,$40,$40,$40,$40,$40,$40,$40,$40,$7d

PLAY_GAME_OVER_MUSIC:
	LDA	#1
	STA	MUSIC_STATE
	LDA	UNIT_TYPE
	CMP	#0
	BEQ	PGOM
;	LDA #6			;sid
	LDA	#0			;pick song
	SEI
	JSR	MUSIC		;START MUSIC
	CLI
	RTS
PGOM:
;	LDA #7		;sid
	LDA	#1		;pick song
	SEI
	JSR	MUSIC	;START MUSIC
	CLI
	RTS

DISPLAY_WIN_LOSE:
	LDX	#0
	LDA	UNIT_TYPE
	CMP	#0
	BEQ	DWL5
DWL1:	LDA	WIN_MSG,X
	STA SCREEN_RAM+$0088,X
	INX
	CPX	#8
	BNE	DWL1
	RTS
DWL5:	LDA	LOS_MSG,X
	STA SCREEN_RAM+$0088,X
	INX
	CPX	#9
	BNE	DWL5
	RTS

WIN_MSG:	!SCR"you win!"
LOS_MSG:	!SCR"you lose!"

PRINT_INTRO_MESSAGE:
	LDA	#<INTRO_MESSAGE
	STA	ZP0
	LDA	#>INTRO_MESSAGE
	STA	ZP1
	JSR	PRINT_INFO
	RTS

;This routine will print something to the "information" window
;at the bottom left of the screen.  You must first define the 
;source of the text in ZP0. The text should terminate with
;a null character.
PRINT_INFO:
	JSR	SCROLL_INFO	;New text always causes a scroll
	LDY	#0
	STY	PRINTX
PI01:	LDA	(ZP0),Y
	CMP	#0	;null terminates string
	BNE	PI02
	RTS
PI02:	CMP	#255	;return
	BNE	PI03
	LDX	#0
	STX	PRINTX
	JSR	SCROLL_INFO
	JMP	PI04
PI03:	LDX	PRINTX
	STA	SCREEN_RAM+$03C0,X
	INC	PRINTX
PI04:	INY
	JMP	PI01
PRINTX:	!BYTE 00	;used to store X-cursor location

;This routine scrolls the info screen by one row, clearing
;a new row at the bottom. Do not use the Y register in this function
SCROLL_INFO:
	LDX	#0
SCI1:	LDA	SCREEN_RAM+$0398,X
	STA	SCREEN_RAM+$0370,X
	LDA	SCREEN_RAM+$03C0,X	;BOTTOM ROW
	STA	SCREEN_RAM+$0398,X
	LDA #32
	STA SCREEN_RAM+$03C0,X	;Save space character to bottom row
	INX
	CPX	#33
	BNE	SCI1
	RTS		

INTRO_SCREEN:
	;Switch into bitmap mode
	LDA #$3B
	STA $FF06
	LDA #>TITLE_COLOR_RAM
	STA $FF14
	LDA #$E0
	STA $FF12





;	;Switch to character mode
;	LDA #$1B
;	STA $FF06
;	LDA #>COLOR_RAM
;	STA $FF14


;	LDA	#15
;	STA SID+$0018	;volume
;	LDA	#4		;pick song
	LDA #2
	SEI
	JSR	MUSIC		;Init music
	CLI
	LDA	#1
	STA	MUSIC_STATE
;	JSR	DISPLAY_INTRO_SCREEN
	JSR	DISPLAY_MAP_NAME
	JSR	CHANGE_DIFFICULTY_LEVEL
	LDA	#0
	STA	MENUY
	JSR	HIGHLIGHT_MENU_OPTION
	JSR CLEAR_KEY_BUFFER
ISLOOP:	LDA	BGTIMER1
	CMP	#1
	BNE	IS001B
	LDA	#0
	STA	BGTIMER1
	JSR	HIGHLIGHT_MENU_OPTION
IS001B:
	JSR GETKEY
	CMP	#00
	BEQ	ISLOOP
	CMP	#$11	;CURSOR DOWN
	BNE	IS001
IS001A:	LDA	MENUY
	CMP	#3
	BEQ	ISLOOP
	JSR	UNHIGHLIGHT_MENU_OPTION
	INC	MENUY
	LDA	#3
	STA	SPRITECOLSTATE
	JSR	HIGHLIGHT_MENU_OPTION
	LDX	#SOUND_MENU_BEEP
	JSR	PLAY_SOUND	;SOUND PLAY
	JMP	ISLOOP
IS001:	CMP	#$91	;CURSOR UP
	BNE	IS002
IS002A:	LDA	MENUY
	CMP	#0
	BEQ	ISLOOP
	JSR	UNHIGHLIGHT_MENU_OPTION
	DEC	MENUY
	LDA	#3
	STA	SPRITECOLSTATE
	JSR	HIGHLIGHT_MENU_OPTION
	LDX	#SOUND_MENU_BEEP
	JSR	PLAY_SOUND	;SOUND PLAY
	JMP	ISLOOP
IS002:	CMP	#32	;SPACE
	BNE	IS003
	JMP	EXEC_COMMAND
IS003:	CMP	KEY_MOVE_UP
	BNE	IS004
	JMP	IS002A
IS004:	CMP	KEY_MOVE_DOWN
	BNE	IS005
	JMP	IS001A
IS005:	CMP	#13	;RETURN
	BNE	IS006
	JMP	EXEC_COMMAND	
IS006:	JMP	ISLOOP


EXEC_COMMAND:
	LDX	#SOUND_MENU_EXEC
	JSR	PLAY_SOUND	;SOUND PLAY
	LDA	MENUY
	CMP	#00	;START GAME
	BNE	EXEC1
EXEC_WAIT:
	LDA SOUND_PLAYING
	CMP #$FF
	BNE EXEC_WAIT
	LDA	#0
	STA	MUSIC_STATE
	;LDA	#0
	;STA SID+$0018	;volume
	JSR	PAUSE_UNTIL_NEXT_CYCLE
	
	;Switch to character mode
	LDA #$1B
	STA $FF06
	LDA #>COLOR_RAM
	STA $FF14

	JSR	SET_CONTROLS

	JMP	INIT_GAME
EXEC1:	CMP	#2	;DIFF LEVEL
	BNE	EXEC05
	INC	DIFF_LEVEL
	LDA	DIFF_LEVEL
	CMP	#3
	BNE	EXEC02
	LDA	#0
	STA	DIFF_LEVEL
EXEC02:	JSR	CHANGE_DIFFICULTY_LEVEL
	JMP	ISLOOP
EXEC05:	CMP	#1	;cycle map
	BNE	EXEC06
	JSR	CYCLE_MAP
EXEC06:	CMP	#3
	BNE	EXEC07
	JSR	CYCLE_CONTROLS
EXEC07:	JMP	ISLOOP

;This routine simply pauses until the next interrupt cycle
;completes.  This will hopefully keep the sound from hanging
;when the disk drive starts up.
PAUSE_UNTIL_NEXT_CYCLE:
	LDX	#0
PUNC1:	LDA	#0
	STA	BGTIMER1
PUNC2:	LDA	BGTIMER1
	CMP	#0
	BEQ	PUNC2
	INX
	CPX	#2
	BNE	PUNC1
	RTS

CYCLE_CONTROLS:
	LDA	#0
	STA	KEYS_DEFINED
	INC	CONTROL
	LDA	CONTROL
	CMP	#3
	BNE	CCON2
	LDA	#0
	STA	CONTROL
CCON2:	;display control method on screen
	LDY	CONTROL
	LDA	CONTROLSTART,Y
	TAY
	LDX	#0
CCON3:	LDA	CONTROLTEXT,Y
	STA SCREEN_RAM+$00CC,X
	INX
	INY
	CPX	#10
	BNE	CCON3

	LDA #<CONTROLTEXT
	STA ZP0
	LDA #>CONTROLTEXT
	STA ZP1
	LDY CONTROL
	LDA CONTROLSTART,Y
	CLC
	ADC ZP0
	STA ZP0
	LDA ZP1
	ADC #0
	STA ZP1
	LDA #<TITLE_RAM+$0521
	STA ZP2
	LDA #>TITLE_RAM+$0521
	STA ZP3
	LDY #0
CCON4:	
	LDA	(ZP0),Y
	LDX #>CHAR_RAM
	CLC
	ROL
	BCC CCON5
	INX
CCON5:
	CLC
	ROL
	BCC CCON6
	INX
CCON6:
	CLC
	ROL
	BCC CCON7
	INX
CCON7:
	STA ZP4
	TXA
	CLC
	ADC #<CHAR_RAM
	STA ZP5
	TYA
	TAX
	LDY #0
CCON8:
	LDA (ZP4),Y
	STA	(ZP2),Y
	INY
	CPY #8
	BNE CCON8
	TXA
	TAY
	CLC
	LDA ZP2
	ADC #8
	STA ZP2
	LDA ZP3
	ADC #0
	STA ZP3
	INY
	CPY	#10
	BNE	CCON4

	RTS

CONTROLTEXT:	!SCR"keyboard  "
				!SCR"custom key"
				!SCR"snes pad  "
CONTROLSTART:	!BYTE 00,10,20

CYCLE_MAP:
	INC	SELECTED_MAP
	LDA	SELECTED_MAP
	CMP	#12	;max number of maps
	BNE	CYM1
	LDA	#0
	STA	SELECTED_MAP
CYM1:	JSR	DISPLAY_MAP_NAME
	RTS

DISPLAY_MAP_NAME:
	LDA #<TITLE_RAM+$08C8
	STA ZP2
	LDA #>TITLE_RAM+$08C8
	STA ZP3
	JSR	CALC_MAP_NAME
DMN1:	
	LDA	(ZP0),Y
	LDX #>CHAR_RAM
	CLC
	ROL
	BCC DMN2
	INX
DMN2:
	CLC
	ROL
	BCC DMN3
	INX
DMN3:
	CLC
	ROL
	BCC DMN4
	INX
DMN4:
	STA ZP4
	TXA
	CLC
	ADC #<CHAR_RAM
	STA ZP5
	TYA
	TAX
	LDY #0
DMN5:
	LDA (ZP4),Y
	STA	(ZP2),Y
	INY
	CPY #8
	BNE DMN5
	TXA
	TAY
	CLC
	LDA ZP2
	ADC #8
	STA ZP2
	LDA ZP3
	ADC #0
	STA ZP3
	INY
	CPY	#16
	BNE	DMN1
	;now set the mapname for the filesystem load
	LDA	SELECTED_MAP
	CLC
	ADC	#65
	STA	MAPNAME+6
	RTS	

CALC_MAP_NAME:
	;FIND MAP NAME
	LDA	SELECTED_MAP
	STA	ZP0
	LDA	#0
	STA	ZP1
	;multiply by 16 by shifting 4 times to left.
	ASL	ZP0
	ROL	ZP1
	ASL	ZP0
	ROL	ZP1
	ASL	ZP0
	ROL	ZP1
	ASL	ZP0
	ROL	ZP1
	;now add offset for mapnames	
	LDA	ZP0
	CLC
	ADC	#<MAP_NAMES
	STA	ZP0
	LDA	ZP1
	ADC	#>MAP_NAMES
	STA	ZP1
	LDY	#0
	RTS

HIGHLIGHT_MENU_OPTION:
	LDY	MENUY
	LDA	MENU_CHART_L,Y
	STA	ZP0
	STA ZP2
	LDA	#>TITLE_COLOR_RAM+$0400
	STA	ZP1
	LDA #>TITLE_COLOR_RAM;
	STA ZP3
	LDY	#0
RMO1:
	LDA #$01
	STA	(ZP0),Y
	LDA ANIM_COLOR
	STA (ZP2),Y 
	INY
	CPY	#10
	BNE	RMO1	
	RTS
MENUY	!BYTE	$00	;CURRENT MENU SELECTION
MENU_CHART_L:
	!BYTE $2C,$54,$7C,$A4;,$CC
UNHIGHLIGHT_MENU_OPTION:
	LDY	MENUY
	LDA	MENU_CHART_L,Y
	STA	ZP0
	STA ZP2
	LDA	#>TITLE_COLOR_RAM+$0400
	STA	ZP1
	LDA #>TITLE_COLOR_RAM
	STA ZP3
	LDY	#0
URMO1:	LDA	#$50
	STA	(ZP0),Y
	LDA #$06
	STA (ZP2),Y
	INY
	CPY	#10
	BNE	URMO1	
	RTS

CHANGE_DIFFICULTY_LEVEL:
	LDX	DIFF_LEVEL
	LDA #<ROBOT_FACE		;Modify the 'self modifying' locations below to load the face data at
	CLC
	ADC FACE_LEVEL,X
	STA CDL0+1
	STA CDL1+1
	LDA #>ROBOT_FACE
	ADC #0
	STA CDL0+2
	STA CDL1+2
	LDX #0
	;DO CHARACTERS FIRST
CDL0:
	LDA	ROBOT_FACE,X		;Self modifying to point at the right level
	LDY ROBOT_FACE_TILE_OFFSET,X
	STA SCREEN_RAM+$00DD,Y
	INX
	CPX #8
	BNE CDL0
CDL1:
	LDA ROBOT_FACE,X		;Self modifying
	LDY ROBOT_FACE_TILE_OFFSET,X
	STA COLOR_RAM+$00DD,Y
	INX
	CPX #14
	BNE CDL1
	;NOW DO BITMAP
	LDX DIFF_LEVEL
	LDY FACE_LEVEL_BITMAP,X
	LDX #0
RFB0
	LDA ROBOT_FACE_BITMAP,Y
	STA TITLE_RAM+$0C28,X
	INY
	INX
	CPX #24
	BNE RFB0
	RTS
	
DIFF_LEVEL	!BYTE 01	;default medium

;This routine is run after the map is loaded, but before the
;game starts.  If the diffulcty is set to normal, nothing 
;actually happens.  But if it is set to easy or hard, then
;some changes occur accordingly.
SET_DIFF_LEVEL:
	LDA	DIFF_LEVEL
	CMP	#0	;easy
	BNE	SDLE1
	JMP	SET_DIFF_EASY
SDLE1:	CMP	#2	;hard
	BNE	SDLE2
	JMP	SET_DIFF_HARD
SDLE2:	RTS

SET_DIFF_EASY:
	;Find all hidden items and double the quantity.
	LDX	#48
SDE1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	SDE2
	CMP	#128	;KEY
	BEQ	SDE2
	ASL	UNIT_A,X	;item qty
SDE2:	INX
	CPX	#64
	BNE	SDE1	
	RTS

SET_DIFF_HARD:
	;Find all hoverbots and change AI
	LDX	#0
SDH1:	LDA	UNIT_TYPE,X
	CMP	#2	;hoverbot left/right
	BEQ	SDH4
	CMP	#3	;hoverbot up/down
	BEQ	SDH4
SDH2:	INX	
	CPX	#28
	BNE	SDH1
	RTS
SDH4:	LDA	#4	;hoverbot attack mode
	STA	UNIT_TYPE,X
	JMP	SDH2


;This chart contains the left-most staring position for each
;row of tiles on the map-editor. 7 Rows.
MAP_CHART_L:
	!BYTE $00,$78,$F0,$68,$E0,$58,$D0

MAP_CHART_H:
	!BYTE >SCREEN_RAM,>SCREEN_RAM,>SCREEN_RAM,>SCREEN_RAM+$0100,>SCREEN_RAM+$0100,>SCREEN_RAM+$0200,>SCREEN_RAM+$0200

;This routine animates the tile #204 (water) 
;and also tile 148 (trash compactor)
;And also the HVAC fan
ANIMATE_WATER:
	LDA	ANIMATE
	CMP	#1
	BEQ	AW00
	RTS
AW00:	INC	WATER_TIMER
	LDA	WATER_TIMER
	CMP	#20
	BEQ	AW01
	RTS
AW01:	LDA	#0
	STA	WATER_TIMER

	LDA	TILE_DATA_BR+204
	STA	WATER_TEMP1
	LDA	TILE_DATA_MM+204
	STA	TILE_DATA_BR+204
	STA	TILE_DATA_BR+221
	LDA	TILE_DATA_TL+204
	STA	TILE_DATA_MM+204
	LDA	WATER_TEMP1
	STA	TILE_DATA_TL+204

	LDA	TILE_DATA_BL+204
	STA	WATER_TEMP1
	LDA	TILE_DATA_MR+204
	STA	TILE_DATA_BL+204
	STA	TILE_DATA_BL+221
	LDA	TILE_DATA_TM+204
	STA	TILE_DATA_MR+204
	LDA	WATER_TEMP1
	STA	TILE_DATA_TM+204
	STA	TILE_DATA_TM+221

	LDA	TILE_DATA_BM+204
	STA	WATER_TEMP1
	LDA	TILE_DATA_ML+204
	STA	TILE_DATA_BM+204
	STA	TILE_DATA_BM+221
	LDA	TILE_DATA_TR+204
	STA	TILE_DATA_ML+204
	LDA	WATER_TEMP1
	STA	TILE_DATA_TR+204
	STA	TILE_DATA_TR+221

	;now do trash compactor
TRSAN1:	LDA	TILE_COLOR_TR+148
	STA	WATER_TEMP1
	LDA	TILE_COLOR_TM+148
	STA	TILE_COLOR_TR+148
	LDA	TILE_COLOR_TL+148
	STA	TILE_COLOR_TM+148
	LDA	WATER_TEMP1
	STA	TILE_COLOR_TL+148

	LDA	TILE_COLOR_MR+148
	STA	WATER_TEMP1
	LDA	TILE_COLOR_MM+148
	STA	TILE_COLOR_MR+148
	LDA	TILE_COLOR_ML+148
	STA	TILE_COLOR_MM+148
	LDA	WATER_TEMP1
	STA	TILE_COLOR_ML+148

	LDA	TILE_COLOR_BR+148
	STA	WATER_TEMP1
	LDA	TILE_COLOR_BM+148
	STA	TILE_COLOR_BR+148
	LDA	TILE_COLOR_BL+148
	STA	TILE_COLOR_BM+148
	LDA	WATER_TEMP1
	STA	TILE_COLOR_BL+148
	;Now do HVAC fan
HVAC0:	LDA	HVAC_STATE
	CMP	#0
	BEQ	HVAC1
	LDA #$BB
	STA	TILE_DATA_MM+196
	STA	TILE_DATA_TL+201
	LDA #$BC
	STA	TILE_DATA_ML+197
	STA	TILE_DATA_TM+200
	LDA #$99
	STA	TILE_DATA_MR+196	
	STA	TILE_DATA_BM+196	
	STA	TILE_DATA_BL+197
	STA	TILE_DATA_TR+200
	LDA	#0
	STA	HVAC_STATE
	JMP	HVAC2
HVAC1:
	LDA #$99
	STA	TILE_DATA_MM+196
	STA	TILE_DATA_TL+201
	STA	TILE_DATA_ML+197
	STA	TILE_DATA_TM+200
	LDA #$B2
	STA	TILE_DATA_MR+196
	STA	TILE_DATA_TR+200
	LDA	#$B0
	STA	TILE_DATA_BM+196	
	STA	TILE_DATA_BL+197
	LDA	#1
	STA	HVAC_STATE
HVAC2:	;now do cinema screen tiles
	;FIRST COPY OLD LETTERS TO THE LEFT.
	LDA	TILE_DATA_MR+20	;#2
	STA	TILE_DATA_MM+20	;#1
	LDA	TILE_DATA_ML+21	;#3
	STA	TILE_DATA_MR+20	;#2
	LDA	TILE_DATA_MM+21	;#4
	STA	TILE_DATA_ML+21	;#3
	LDA	TILE_DATA_MR+21	;#5
	STA	TILE_DATA_MM+21	;#4
	LDA	TILE_DATA_ML+22	;#6
	STA	TILE_DATA_MR+21	;#5
	;now insert new character.
	LDY	CINEMA_STATE
	LDA	CINEMA_MESSAGE,Y
	STA	TILE_DATA_ML+22	;#6

	INC	CINEMA_STATE
	LDA	CINEMA_STATE
	CMP	#197
	BNE	CINE2
	LDA	#0
	STA	CINEMA_STATE
CINE2:	;Now animate light on server computers
	LDA	TILE_DATA_MR+143
	;CMP	#$D7
	CMP #$C3
	BNE	CINE3
	;LDA	#$D1
	LDA #$BF
	JMP	CINE4
CINE3:
	;LDA #$D7
	LDA	#$C3
CINE4:	STA	TILE_DATA_MR+143
	LDA	#1
	STA	REDRAW_WINDOW
	RTS

WATER_TIMER	!BYTE 00
WATER_TEMP1	!BYTE 00
HVAC_STATE	!BYTE 00
CINEMA_STATE	!BYTE 00

;This is the routine that allows a person to select
;a level and highlights the selection in the information
;display. It is unique to each computer since it writes
;to the screen directly.
ELEVATOR_SELECT:
	LDA	#1
	STA	PLAYER_DIR
	LDA #1
	STA REDRAW_WINDOW
	JSR	DRAW_MAP_WINDOW
	LDX	UNIT
	LDA	UNIT_D,X	;get max levels
	STA	ELEVATOR_MAX_FLOOR
	;Now draw available levels on screen
	LDY	#0
	LDA	#$31
ELS1:	STA	SCREEN_RAM + $03C6,Y
	CLC
	ADC	#01
	INY
	CPY	ELEVATOR_MAX_FLOOR
	BNE	ELS1
	LDA	UNIT_C,X		;what level are we on now?
	STA	ELEVATOR_CURRENT_FLOOR
	;Now highlight current level
;	JSR	ELEVATOR_INVERT
	;Now get user input
	LDA	CONTROL	
	CMP	#2
	BNE	ELS5
	JMP	SELS5
ELS5:
	;Modify color of selected floor
	LDY ELEVATOR_CURRENT_FLOOR
	LDA	ANIM_COLOR
	STA COLOR_RAM+$03C5,Y
	;KEYBOARD INPUT
	JSR GETKEY
	CMP	#$00
	BEQ	ELS5
	;Modify color of selected floor back to green
	TAX
	LDY ELEVATOR_CURRENT_FLOOR
	LDA #$5A
	STA COLOR_RAM+$03C5,Y
	TXA
	CMP	KEY_MOVE_LEFT
	BNE	ELS6
	JSR	ELEVATOR_DEC
	JMP	ELS5
ELS6:	CMP	KEY_MOVE_RIGHT
	BNE	ELS7
	JSR	ELEVATOR_INC
	JMP	ELS5
ELS7:	CMP	#$9D	;CURSOR LEFT
	BNE	ELS8
	JSR	ELEVATOR_DEC
	JMP	ELS5
ELS8:	CMP	#$1D	;CURSOR RIGHT
	BNE	ELS9
	JSR	ELEVATOR_INC
	JMP	ELS5
ELS9:	CMP	#$11	;CURSOR DOWN
	BNE	ELS10
ELS9B:	JSR	SCROLL_INFO
	JSR	SCROLL_INFO
	JSR	SCROLL_INFO
	JSR	CLEAR_KEY_BUFFER
	RTS
ELS10:	CMP	KEY_MOVE_DOWN
	BEQ	ELS9B
ELS11:	JMP	ELS5
SELS5:	;SNES INPUT
	JSR	SNES_CONTROLER_READ
	LDA	NEW_LEFT
	CMP	#1	
	BNE	SELS8
	;Modify color of selected floor back to green
	LDY ELEVATOR_CURRENT_FLOOR
	LDA #$5A
	STA COLOR_RAM+$03C5,Y
	JSR	ELEVATOR_DEC
	LDA	#0
	STA	NEW_LEFT
	JMP	SELS5
SELS8:	LDA	NEW_RIGHT
	CMP	#1
	BNE	SELS9
	;Modify color of selected floor back to green
	LDY ELEVATOR_CURRENT_FLOOR
	LDA #$5A
	STA COLOR_RAM+$03C5,Y
	JSR	ELEVATOR_INC
	LDA	#0
	STA	NEW_RIGHT
	JMP	SELS5
SELS9:	LDA	NEW_DOWN
	CMP	#1	
	BNE	SELS10
	;Modify color of selected floor back to green
	LDY ELEVATOR_CURRENT_FLOOR
	LDA #$5A
	STA COLOR_RAM+$03C5,Y
	JSR	SCROLL_INFO
	JSR	SCROLL_INFO
	JSR	SCROLL_INFO
	LDA	#15
	STA	KEYTIMER
	LDA	#0
	STA	NEW_DOWN
	RTS
SELS10:	
	;Animate floor number
	LDY ELEVATOR_CURRENT_FLOOR
	LDA	ANIM_COLOR
	STA COLOR_RAM+$03C5,Y
	JMP	SELS5

ELEVATOR_MAX_FLOOR	!BYTE 00
ELEVATOR_CURRENT_FLOOR	!BYTE 00

EL_PANEL_SPRITE:
	!BYTE	63,71,79,87,95,103,111

ELEVATOR_INC:
	LDA	ELEVATOR_CURRENT_FLOOR
	CMP	ELEVATOR_MAX_FLOOR
	BNE	ELVIN1
	RTS
ELVIN1:	INC	ELEVATOR_CURRENT_FLOOR
;	JSR	ELEVATOR_INVERT
	JSR	ELEVATOR_FIND_XY
	RTS
ELEVATOR_DEC:
	LDA	ELEVATOR_CURRENT_FLOOR
	CMP	#1
	BNE	ELVDE1
	RTS
ELVDE1:	DEC	ELEVATOR_CURRENT_FLOOR
;	JSR	ELEVATOR_INVERT
	JSR	ELEVATOR_FIND_XY
	RTS

ELEVATOR_FIND_XY:
	LDX	#32	;start of doors
ELXY1:	LDA	UNIT_TYPE,X
	CMP	#19	;elevator
	BNE	ELXY5
	LDA	UNIT_C,X
	CMP	ELEVATOR_CURRENT_FLOOR
	BNE	ELXY5
	JMP	ELXY10
ELXY5:	INX
	CPX	#48
	BNE	ELXY1
	RTS
ELXY10:	LDA	UNIT_LOC_X,X	;new elevator location
	STA	UNIT_LOC_X	;player location
	SEC
	SBC	#5
	STA	MAP_WINDOW_X
	LDA	UNIT_LOC_Y,X	;new elevator location
	STA	UNIT_LOC_Y	;player location
	DEC	UNIT_LOC_Y
	SEC
	SBC	#4
	STA	MAP_WINDOW_Y
	LDA #1
	STA REDRAW_WINDOW
	JSR	DRAW_MAP_WINDOW
;	JSR	ELEVATOR_INVERT
	LDX	#SOUND_MENU_BEEP	;elevator sound (menu beep)
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS

SET_CONTROLS:
	LDA	CONTROL
	CMP	#1	;CUSTOM KEYS
	BNE	SETC1
	JSR	SET_CUSTOM_KEYS
	RTS		
SETC1:	;load standard values for key controls
	LDY	#0
SETC2:	LDA	STANDARD_CONTROLS,Y
	STA	KEY_MOVE_UP,Y
	INY
	CPY	#13
	BNE	SETC2
	RTS

SET_CUSTOM_KEYS:
	LDA	KEYS_DEFINED
	CMP	#0
	BEQ	SCK00
	RTS
SCK00:	JSR	GREEN_SCREEN	;set entire screen to monochrome
	;SET SOURCE
	LDA	#<SCR_CUSTOM_KEYS
	STA	ZP0
	LDA	#>SCR_CUSTOM_KEYS
	STA	ZP1
	;SET DESTINATION
	LDA	#<SCREEN_RAM
	STA	ZP2
	LDA	#>SCREEN_RAM
	STA	ZP3
	;SET END
	LDA	#>SCREEN_RAM+$0300
	STA	DGS5+1
	LDA	#$E7
	STA	DGS6+1
	JSR	DECOMPRESS_SCREEN	
	;GET KEYS FROM USER
	LDA	#0
	STA	TEMP_A
	LDA	#>SCREEN_RAM+$0100
	STA	ZP1
	LDA	#$51
	STA	ZP0
SCK01:
	JSR GETKEY
	CMP	#00
	BEQ	SCK01
	LDY	TEMP_A
	STA	KEY_MOVE_UP,Y
	STA	DECNUM
	JSR	DECWRITE
	LDA	ZP0
	CLC
	ADC	#40
	STA	ZP0
	LDA	ZP1
	ADC	#00
	STA	ZP1
	INC	TEMP_A
	LDA	TEMP_A
	CMP	#13
	BNE	SCK01
	LDA	#01
	STA	KEYS_DEFINED
	RTS

;This is technically part of a background routine, but it has to
;be here in the main code because the screen effects are unique
;to each system.
DEMATERIALIZE:
	LDX	UNIT
	INC	UNIT_TIMER_B,X
	LDA	UNIT_TIMER_B,X
	TAY
	AND #%00000010
	BEQ DEMA0
	;Calculate color intensity based on UNIT_TIMER
	TYA
	EOR #%11111111
	ASL
	AND #%01110000
	ORA #%00000110	;Blue
	JMP DEMA00
DEMA0:	
	LDA #$01
DEMA00:
	JSR PLAYER_COLOR
	STY TILE			;PLAYER_COLOR sets Y to #97 (player character)
	LDA #<SCREEN_RAM+$0177
	STA ZP0
	LDA #>SCREEN_RAM+$0177
	STA ZP1
	JSR PLOT_TRANSPARENT_TILE

	LDX	UNIT
	LDA	UNIT_TIMER_B,X
	CMP	#64
	BEQ	DEMA1
	JMP	AILP
DEMA1:	;TRANSPORT COMPLETE
	;Return player sprite color to normal
	LDA #$71;
	JSR PLAYER_COLOR;
	LDA	UNIT_B,X
	CMP	#1		;transport somewhere
	BEQ	DEMA2
	LDA	#2		;this means game over condition
	STA	UNIT_TYPE	;player type
	LDA	#7		;Normal transporter pad
	STA	UNIT_TYPE,X
	JMP	AILP
DEMA2:	LDA	#97
	STA	UNIT_TILE
	LDA	UNIT_C,X	;target X coordinates
	STA	UNIT_LOC_X
	LDA	UNIT_D,X	;target Y coordinates
	STA	UNIT_LOC_Y
	LDA	#7		;Normal transporter pad
	STA	UNIT_TYPE,X
	JSR	CACULATE_AND_REDRAW
	JMP	AILP
	
;This function changes the color of the player character.
;Pass in the color in A register
;Y should contain #97 (player character) upon return
PLAYER_COLOR:
	LDY #97		;Player character
	STA TILE_COLOR_TL,Y;
	STA TILE_COLOR_TM,Y;
	STA TILE_COLOR_ML,Y;
	STA TILE_COLOR_MM,Y;
	STA TILE_COLOR_MR,Y;
	STA TILE_COLOR_BM,Y;
	STA TILE_COLOR_BR,Y;
	RTS

;This function updates the animation for the player. 2 frames for each direction, also a death frame
ANIMATE_PLAYER:
	LDA	PLAYER_ANI
	CMP	#0
	BEQ	PANI1
	LDA	#0
	STA	PLAYER_ANI
	TAX
	JMP	PANI2	
PANI1:	LDA	#56
	STA	PLAYER_ANI
	LDX #1
PANI2:	
	JSR PLAY_SOUND	;Play sound 0 or 1 for the walk sounds
	LDX PLAYER_DIR
	LDA PLAYER_ANI_L,X
	STA ZP0
	LDA PLAYER_ANI_H,X
	STA ZP1
	LDX	#0
	LDY	PLAYER_ANI
PANI3:	LDA	(ZP0),Y
	STA	CHAR_RAM+$06E8,X
	INY
	INX
	CPX	#56
	BNE	PANI3
	RTS
	
;START_LEVEL_MUSIC:
;	LDY	SELECTED_MAP
;	LDA	LEVEL_MUSIC,Y	;pick song
;	SEI
;	JSR	MUSIC		;START MUSIC
;	CLI		;REMARKED OUT FOR TED

;	LDA	#1
;	STA	MUSIC_STATE
;	RTS

;TOGGLE_MUSIC:
;	LDA	USER_MUSIC_ON
;	CMP	#1
;	BNE	TGMUS1
;	LDA	#5	;pick song
;	SEI
;	JSR	MUSIC		;START MUSIC
;	CLI
;	LDA	#<MSG_MUSICOFF
;	STA	ZP0
;	LDA	#>MSG_MUSICOFF
;	STA	ZP1
;	JSR	PRINT_INFO
;	LDA	#0
;	STA	USER_MUSIC_ON
;	RTS
;TGMUS1:	LDA	#<MSG_MUSICON
;	STA	ZP0
;	LDA	#>MSG_MUSICON
;	STA	ZP1
;	JSR	PRINT_INFO
;	LDA	#1
;	STA	USER_MUSIC_ON
;	JMP	START_LEVEL_MUSIC
	
;This function fetched a key off the keyboard queue. It is mostly cloned from the kernal.
;Unfortunately, the kernal calls to clear interrupts, so this is a version that does not.
KEYIN:
	LDA $EF
	ORA $055D
	BEQ KI2
	LDX $055D       	;are there any function keys?
	BEQ KI0         	;branch if not
	LDY $055E      		;get index to current char
	LDA $0567,Y    		;get current byte
	DEC $055D       	;1 byte down
	INC $055E      		;bump index to next char
	RTS
KI0:
	LDY $0527       	;get key from buffer
KI1:
	lda $0528,x
	sta $0527,x
	inx
	cpx $ef
	bne KI1
	dec $ef
	tya
KI2:
	rts

INVENTORY:	;KEEP THESE ENTRIES IN THIS ORDER FOR LOOPING OVER THEM!!!
KEYS				!BYTE 	00	;bit0=spade bit2=heart bit3=star
INV_BOMBS			!BYTE	00	;How many bombs do we have
INV_EMP				!BYTE	00	;How many EMPs do we have
INV_MEDKIT			!BYTE	00	;How many medkits do we have?
INV_MAGNET			!BYTE	00	;How many magnets do we have?
AMMO_PISTOL			!BYTE	00	;how much ammo for the pistol
AMMO_PLASMA			!BYTE	00	;how many shots of the plasmagun
MAGNET_ACT			!BYTE	00	;0=no magnet active 1=magnet active
PLASMA_ACT			!BYTE	00	;0=No plasma fire active 1=plasma fire active
BIG_EXP_ACT			!BYTE	00	;0=No explosion active 1=big explosion active
SELECTED_WEAPON		!BYTE	00	;0=none 1=pistol 2=plasmagun
SELECTED_ITEM		!BYTE	00	;0=none 1=bomb 2=emp 3=medkit

ANIMATE				!BYTE 	01	;0=DISABLED 1=ENABLED
RANDOM				!BYTE	00	;used for random number generation
CONTROL				!BYTE	00	;0=keyboard 1=custom keys 2=snes
SELECTED_MAP		!BYTE	00

USER_MUSIC_ON:		!BYTE	1
;LEVEL_MUSIC:		!BYTE	1,0,2,3,0,1,2,3,0,1,3,2

KEYS_DEFINED		!BYTE	00	;DEFAULT =0 
STANDARD_CONTROLS:	!BYTE	73	;MOVE UP
					!BYTE	75	;MOVE DOWN
					!BYTE	74	;MOVE LEFT
					!BYTE	76	;MOVE RIGHT
					!BYTE	87	;FIRE UP
					!BYTE	83	;FIRE DOWN
					!BYTE	65	;FIRE LEFT
					!BYTE	68	;FIRE RIGHT
FUNC1:				!BYTE	133	;CYCLE WEAPONS
FUNC2:				!BYTE	134	;CYCLE ITEMS
					!BYTE	32	;USE ITEM
					!BYTE	90	;SEARCH OBEJCT
					!BYTE	77	;MOVE OBJECT
CHEAT:				!BYTE	223	;CHEAT
FUNC8:				!BYTE	224	;DISPLAY MAP

MAPNAME:  			!PET"level-a"
MAPNAME_END:

INTRO_MESSAGE		!SCR"welcome to plus4-robots!",255
					!SCR"by david murray 2021",255
					!SCR"ported by jim wright",0
MSG_CANTMOVE		!SCR"can't move that!",0
MSG_BLOCKED			!SCR"blocked!",0
MSG_SEARCHING		!SCR"searching",0
MSG_NOTFOUND		!SCR"nothing found here.",0
MSG_FOUNDKEY		!SCR"you found a key card!",0
MSG_FOUNDGUN		!SCR"you found a pistol!",0
MSG_FOUNDEMP		!SCR"you found an emp device!",0
MSG_FOUNDBOMB		!SCR"you found a timebomb!",0
MSG_FOUNDPLAS		!SCR"you found a plasma gun!",0
MSG_FOUNDMED		!SCR"you found a medkit!",0
MSG_FOUNDMAG		!SCR"you found a magnet!",0
MSG_MUCHBET			!SCR"ahhh, much better!",0
MSG_EMPUSED			!SCR"emp activated!",255
					!SCR"nearby robots are rebooting.",0
MSG_TERMINATED		!SCR"you're terminated!",0
MSG_TRANS1			!SCR"transporter will not activate",255
					!SCR"until all robots destroyed.",0
MAP_NAMES			!SCR"01-research lab "
					!SCR"02-headquarters "
					!SCR"03-the village  "
					!SCR"04-the islands  "
					!SCR"05-downtown     "
					!SCR"06-pi university"
					!SCR"07-more islands "
					!SCR"08-robot hotel  "
					!SCR"09-forest moon  "
					!SCR"10-death tower  "
					!SCR"11-bunker       "
					!SCR"12-castle robot "
MSG_ELEVATOR		!SCR"[ elevator panel ]  down",255
					!SCR"[  select level  ]  opens",0
MSG_LEVELS			!SCR"[                ]  door",0
MSG_MAP				!SCR"[help] key toggles robots",0
MSG_PAUSED			!SCR"game paused.",255
					!SCR"exit game (y/n)",0
MSG_MUSICON			!SCR"music on.",0
MSG_MUSICOFF		!SCR"music off.",0

CINEMA_MESSAGE:		!SCR"coming soon: space balls 2 - the search for more money, "
					!SCR"attack of the paperclips: clippy's revenge, "
					!SCR"it came from planet earth, "
					!SCR"rocky 5000, all my circuits the movie, "
					!SCR"conan the librarian, and more! " 




;Create left and right black columns to each side of the map (4 characters wide on each side)
;Start at row 4 and stop after 16 rows being drawn
MAP_COLUMNS:
	LDA #<BITMAP_RAM+2*40*8+36*8;		;2 rows * 40 chars wide * 8 bytes + 36 chars * 8 bytes (right column)
	STA ZP2
	LDA #>BITMAP_RAM+2*40*8+36*8;
	STA ZP3
	LDA #<BITMAP_COLOR_0+$0400+2*40+36	;Color offset. 2 rows * 40 chars wide + 36 chars (right column)
	STA ZP4
	LDA #>BITMAP_COLOR_0+$0400+2*40+36
	STA ZP5
	LDA #<BITMAP_COLOR_1+$0400+2*40+36	;Color offset. 2 rows * 40 chars wide + 36 chars (right column)
	STA ZP6
	LDA #>BITMAP_COLOR_1+$0400+2*40+36
	STA ZP7
	LDA #<BITMAP_COLOR_2+$0400+2*40+36	;Color offset. 2 rows * 40 chars wide + 36 chars (right column)
	STA ZP8
	LDA #>BITMAP_COLOR_2+$0400+2*40+36
	STA ZP9
	LDA #<BITMAP_COLOR_3+$0400+2*40+36	;Color offset. 2 rows * 40 chars wide + 36 chars (right column)
	STA ZPA
	LDA #>BITMAP_COLOR_3+$0400+2*40+36
	STA ZPB
	LDX #17							;Number of rows to create column
MAP0:
	LDA #%10101010					;This color will be set as black
	LDY #0
MAP1:
	STA (ZP2),Y						;Right column
	INY
	CPY #64
	BNE MAP1
	LDA ZP2							;Move to next screen row
	CLC
	ADC #<$0140
	STA ZP2
	LDA ZP3
	ADC #>$0140
	STA ZP3
	LDA #0							;Add color data
	TAY
	CPX #17
	BNE MAP3
	LDY #4
MAP3:
	STA (ZP4),Y						;1 of 4 color locations for mini-map
	
	;LDA #$51
	
	STA (ZP6),Y						;2 of 4 color locations for mini-map
	
	;LDA #$63
	
	STA (ZP8),Y						;3 of 4 color locations for mini-map
	
	;LDA #$22
	
	STA (ZPA),Y						;4 of 4 color locations for mini-map
	INY
	CPY #8
	BNE MAP3
MAP4:
	LDY #0							;Move color pointers to next screen row
MAP5:
	LDA ZP4,Y
	CLC
	ADC #40
	STA ZP4,Y
	LDA ZP5,Y
	ADC #0
	STA ZP5,Y
	INY
	INY
	CPY #8
	BNE MAP5
	DEX								;Loop if we havent finished processing 16 rows
	BNE MAP0
	;Clear characters above and below the map
	LDA #32
	LDX #0
MAP6:
	STA SCREEN_RAM+0*40,X
	STA SCREEN_RAM+17*40,X
	INX
	CPX #160
	BNE MAP6
	RTS

;This function backs up important data that falls in the range of our bitmap color ranges
MAP_BACKUP:
;First backup important data at $0300-$07FF. Store it in the unused upper area of the mini-map bitmap to restore later
	LDX #0
MB0:
	LDA $04FC,X					;Backup 'Table of pending jiffies' (accessed during load routine)
	STA BITMAP_RAM+$0280,X
	INX
	CPX #4
	BNE MB0
	LDX #0
MB1:
	LDA $0300,X					;Backup Kernal Vector Pointers
	STA BITMAP_RAM+$0284,X
	INX
	CPX #50
	BNE MB1
;Then copy color data from the title screen bitmap into $0280-$04FF and $0580-$07FF, skipping over $0500-$057F (storage for keyboard is here)
	LDX #0
MB2:
	LDA TITLE_COLOR_RAM+$0078,X
	STA BACKUP_DATA+$0000,X
	LDA TITLE_COLOR_RAM+$00F8,X
	STA BACKUP_DATA+$0080,X
	LDA TITLE_COLOR_RAM+$0178,X
	STA BACKUP_DATA+$0100,X
	LDA TITLE_COLOR_RAM+$01F8,X
	STA BACKUP_DATA+$0180,X
	LDA TITLE_COLOR_RAM+$0278,X
	STA BACKUP_DATA+$0200,X
	LDA TITLE_COLOR_RAM+$0478,X
	STA BACKUP_DATA+$0300,X
	LDA TITLE_COLOR_RAM+$04F8,X
	STA BACKUP_DATA+$0380,X
	LDA TITLE_COLOR_RAM+$0578,X
	STA BACKUP_DATA+$0400,X
	LDA TITLE_COLOR_RAM+$05F8,X
	STA BACKUP_DATA+$0480,X
	LDA TITLE_COLOR_RAM+$0678,X
	STA BITMAP_RAM+$200,X
;Also copy data from $D000-$D200 into the unused upper area of the mini-map bitmap to restore later
	LDA $D000,X
	STA BITMAP_RAM,X
	LDA $D080,X
	STA BITMAP_RAM+$0080,X
	LDA $D100,X
	STA BITMAP_RAM+$0100,X
	LDA $D180,X
	STA BITMAP_RAM+$0180,X
	INX
	CPX #128
	BNE MB2
	RTS

;This function restores important data that was backed up before showing the mini-map
MAP_RESTORE:
;Copy color data back into the title screen bitmap
	LDX #0
MR0:
	LDA BACKUP_DATA+$0000,X
	STA TITLE_COLOR_RAM+$0078,X
	LDA BACKUP_DATA+$0080,X
	STA TITLE_COLOR_RAM+$00F8,X
	LDA BACKUP_DATA+$0100,X
	STA TITLE_COLOR_RAM+$0178,X
	LDA BACKUP_DATA+$0180,X
	STA TITLE_COLOR_RAM+$01F8,X
	LDA BACKUP_DATA+$0200,X
	STA TITLE_COLOR_RAM+$0278,X
	LDA BACKUP_DATA+$0300,X
	STA TITLE_COLOR_RAM+$0478,X
	LDA BACKUP_DATA+$0380,X
	STA TITLE_COLOR_RAM+$04F8,X
	LDA BACKUP_DATA+$0400,X
	STA TITLE_COLOR_RAM+$0578,X
	LDA BACKUP_DATA+$0480,X
	STA TITLE_COLOR_RAM+$05F8,X
	LDA BITMAP_RAM+$0200,X
	STA TITLE_COLOR_RAM+$0678,X
;Also copy data back to $D000-$D200
	LDA BITMAP_RAM,X
	STA $D000,X
	LDA BITMAP_RAM+$0080,X
	STA $D080,X
	LDA BITMAP_RAM+$0100,X
	STA $D100,X
	LDA BITMAP_RAM+$0180,X
	STA $D180,X
	INX
	CPX #128
	BNE MR0
;Now restore important to $0300-$07FF.
	LDX #0
MR1:
	LDA BITMAP_RAM+$0280,X		;Restore 'Table of pending jifffies' (accessed during load routine)
	STA $04FC,X
	INX
	CPX #4
	BNE MR1
	LDX #0
MR2:
	LDA BITMAP_RAM+$0284,X		;Restore Kernal Jump Vector Pointers
	STA $0300,X
	INX
	CPX #50
	BNE MR2
	RTS

;Draw the mini-map on the BITMAP_RAM and BITMAP_COLOR_0-3
MAP_DRAW:
	LDA #<MAP					;Pointer to the level map data
	STA ZP0
	LDA #>MAP
	STA ZP1
	LDA #<3*40+4				;Location on the screen. 3 rows * 40 characters + 4 characters
	STA ZP2
	LDA #>3*40+4
	STA ZP3
	LDA #<BITMAP_RAM+3*40*8+4*8	;Pointer to location within bitmap. 3 rows * 40 characters * 8 bytes + 4 characters * 8 bytes
	STA ZP4
	LDA #>BITMAP_RAM+3*40*8+4*8
	STA ZP5
	;Build the MAP_ROW_BG color table
;	LDX #0
	;LDY	SELECTED_MAP
;	LDA	MAP_COLOR_BG_DEFAULT;,Y
;MD0:
;	STA MAP_ROW_BG,X
;	INX
;	CPX #64
;	BNE MD0
	
	
;	LDX MAP_0_ROW_BG_INDEX,Y	;TEMPORARILY REMARKED OUT, JUST USING A SINGLE BACKGROUND COLOR FOR WHOLE MAP RIGHT NOW
;MD1:
;	LDY MAP_0_ROW_BG,X
;	CPY #$FF
;	BEQ MD2
;	INX
;	LDA MAP_0_ROW_BG,X
;	STA MAP_ROW_BG,Y
;	INX
;	BNE MD1
;MD2:	
	LDX #0
	LDY #0
MD3:
	STX TEMP_X				;Current X/4 position within map (0-31) (will multiply by 4 by left shifting, since each byte contains 4 pixels on the bitmap)
	STY TEMP_Y				;Current Y position within map (0-63)
	JSR MAP_PLOT			;Calculate what order to process the next 4 pixels and all the correct positions within the bitmap, color ram, etc and plot the pixel/color data
	;Increment position within the map
	LDX TEMP_X
	LDY TEMP_Y
	INX
	CPX #32
	BNE MD3
	INY
	LDA ZP0					;Increment map pointer
	CLC
	ADC #128
	STA ZP0
	LDA ZP1
	ADC #0
	STA ZP1
	TYA						;Check if we should go down to the next character row (Every 4 rows of the map, 8 pixels)
	AND #%00000011
	BNE MD4
	LDA ZP2					;Increment character position on screen
	CLC
	ADC #40
	STA ZP2
	LDA ZP3
	ADC #0
	STA ZP3
	LDA ZP4					;Increment bitmap pointer
	CLC
	ADC	#8*8-6				;Incrementing 8 characters * 8 bytes - 6 bytes we had previously increased
	STA ZP4
	LDA ZP5
	ADC #1					;Also add 256 bytes (32 characters * 8 bytes)
	STA ZP5
	JMP MD5
MD4:
	LDA ZP4					;Increment the bitmap position by 2 bytes to go 2 pixels down for next map row
	CLC
	ADC #2
	STA ZP4
	LDA ZP5
	ADC #0
	STA ZP5
MD5:
	LDX #0
	CPY #64
	BNE MD3
	RTS
	
MAP_PLOT:
	;Calculate the priority order of the next 4 pixels (which ones have color priority over another)
	LDY #0
	STY GREENFOUND			;Erase a flag that indicates if we've seen a green tile (to replace a path tile with grass when we run out of colors)
	STY REDFOUND			;Erase a flag that indicates if we've seen a red tile (to replace a path tile with red when we run out of colors)
	STY ORANGEFOUND			;Erase a flag that indicates if we've seen a orange tile (to replace a path tile with orange when we run out of colors)
	STY TEMP_A				;Counter for which pixel (0-3) that we are on
	STY TEMP_B				;Flag to inticate if the current pixel being worked on is low priority
	TXA						;Multiply passed in X position by 4
	ASL
	ASL
	TAY						;Store map X position in Y and fetch the next 4 map tiles
	STY TEMP_C				;Store the initial X position for later retrieval
MP0:
	LDA (ZP0),Y				;Fetch tile
	TAX
MP1:
	LDA TILE_ATTRIB,X		;If tile is movable make it have lower priority, which could make it white when we run out of colors
	AND #%00000100
	BNE MP_LOW
	LDA #2
	CPX #206				;Make path tiles have lower priority and can be converted to a path color or grass color we have if we run out of colors
	BEQ MP_LOW
	CPX #207
	BEQ MP_LOW
	CPX #214
	BEQ MP_LOW
	CPX #202				;Lower priority for a few tiles on the roofs, so we don't get white where the black background should be
	BEQ MP_LOW
	CPX #197
	BEQ MP_LOW
	CPX #201
	BNE MP2
MP_LOW:						;Add flag to make this tile a low priority (2 = path tile, 4 = movable object)
	STA TEMP_B
MP2:
	LDA MAP_TILE_COLORS,X	;Get color out of table
	LDX TEMP_A
	STA TILECOLOR0,X		;Save color
	LDA TEMP_B
	STA PRIORITY0,X			;Save priority
	LDA #0
	STA TEMP_B				;Clear priority flag for next loop
	INX
	STX TEMP_A				;Increase which pixel we are working on (0-3)
	INY
	CPX #4
	BNE MP0
	;Build the colors that will ultimately be used for each tile
	LDA #$71
	STA COLOR0				;Background color 0. Always use white.
	LDX TEMP_Y
	;LDA MAP_ROW_BG,X
	LDA MAP_COLOR_BG_DEFAULT
	STA COLOR1				;Background color 1. Use a single color per row on the map.
	LDA #$FF				;Store $FF in COLOR2 & COLOR3, indicating they haven't had a color set in them yet
	STA COLOR2
	STA COLOR3
	;Loop through the colors we stored on each tile and figure out what the other 2 colors will be, if used
	LDX #0
MP3:
	LDA PRIORITY0,X
	BNE MP6					;The priority is set lower on this tile, skip it for now
	LDA TILECOLOR0,X
	LDY #0
MP4:
	CMP COLOR0,Y
	BEQ MP6					;Found a color that was already used for another tile, continue on
	INY
	CPY #4
	BNE MP4
	LDY COLOR2				;Add color if we have room
	CPY #$FF
	BNE MP5
	STA COLOR2				;Add to COLOR2 and continue the loop
	JMP MP6
MP5:
	STA COLOR3				;Add to COLOR3 and end loop, since we have no more room for colors
	JMP MP10
MP6:
	INX
	CPX #4
	BNE MP3
MP7:
	LDX #0					;Loop through PRIORITY list. If any are set as non-0, set them to 0 and run the loop again
	STX TEMP_D				;Flag for if any of the PRIORITY list were set as non-0
MP8:
	LDA PRIORITY0,X
	BEQ MP9
	LDA #1
	STA TEMP_D				;Found a priority entry that was non-0
	LDA #0
	STA PRIORITY0,X
MP9:
	INX
	CPX #4
	BNE MP8
	LDX #0
	LDA TEMP_D				;Loop again if any any were found with a PRIORITY set
	BNE MP3
MP10:
;Loop through the finalized colors and set some flags if we see certain colors
	LDX #4
MP11:
	LDA COLOR0,X
	CMP MAP_COLOR_BG_DEFAULT	;Green
	BNE MP12
	STX GREENFOUND
MP12:
	CMP #$49				;Orange
	BNE MP13
	STX ORANGEFOUND
MP13:
	CMP #$3B				;Red
	BNE MP14
	STX REDFOUND
MP14:
	DEX
	BNE MP11
;Loop through the 'TILECOLOR#' entries and if they don't have a color matching in 'COLOR#', then we change the color to one of the colors we have
MP15:
	LDA TILECOLOR0,X
	LDY #0
MP16:
	CMP COLOR0,Y
	BEQ MP21
	INY
	CPY #4
	BNE MP16
	LDY TEMP_C				;Didn't find a matching color, fetch what tile this was
	LDA (ZP0),Y
STA ZPA
	CMP #206				;Orange path
	BNE MP17
	LDA REDFOUND
	BEQ MP19
	LDA #$3B				;Red path found, turn orange path into red path instead
	STA TILECOLOR0,X
	JMP MP21
MP17:
	CMP #207				;Red path
	BNE MP18
	LDA ORANGEFOUND
	BEQ MP19
	LDA #$49				;Orange path found, turn red path into orange path instead
	STA TILECOLOR0,X
	JMP MP21
MP18:
	CMP #214				;Gray path
	BNE MP20
MP19:
	LDA GREENFOUND
	BEQ MP20
	LDA MAP_COLOR_BG_DEFAULT	;Green path found, turn gray path into green path instead, since we ran out of the other color
	STA TILECOLOR0,X
	JMP MP21
MP20:
	LDA #$71				;Set tile white, because we have run out of options
	STA TILECOLOR0,X
MP21:
	INC TEMP_C				;Increment the pointer to which tile we are looking at, in case we need to fetch it
	INX
	CPX #4
	BNE MP15
;Add color to color ram that matches that row
	LDA TEMP_Y				;Load what row we are on
	AND #%00000011			;Limit the value to be 0-3
	ASL						;Multiply by 2 and store in X register
	TAX
	LDA MAP_COLOR_RAM_ARRAY,X	;Store pointers to luminance and color data
	CLC
	ADC ZP2
	STA ZP6
	STA ZP8
	LDA MAP_COLOR_RAM_ARRAY+1,X
	ADC ZP3
	STA ZP7
	CLC
	ADC #4
	STA ZP9
	LDY TEMP_X
	LDA COLOR3				;Store luminance data
	AND #%01110000
	STA (ZP6),Y
	LDA COLOR2
	AND #%01110000
	LSR
	LSR
	LSR
	LSR
	ORA (ZP6),Y
	STA (ZP6),Y
	LDA COLOR2				;Store color data
	AND #%00001111
	ASL
	ASL
	ASL
	ASL
	STA (ZP8),Y
	LDA COLOR3
	AND #%00001111
	ORA (ZP8),Y
	STA (ZP8),Y
;Build bitmap byte to place on the screen
	TYA						;Multiply the column by 8
	ASL
	ASL
	ASL
	TAY
	LDX #0
MP22:
;Compare the tile color with our colors to determine which bit pair to place in each pixel
	LDA TILECOLOR0,X
	CMP COLOR1
	BNE MP23
	LDA #%00000011
	BNE MP26
MP23:
	CMP COLOR2
	BNE MP24
	LDA #%00000001
	BNE MP26
MP24:
	CMP COLOR3
	BNE MP25
	LDA #%00000010
	BNE MP26
MP25:
	LDA #%00000000
MP26:
	STA TEMP_A,X
	INX
	CPX #4
	BNE MP22
;Combine the bit pairs and plot it on the bitmap
	LDA TEMP_A
	ASL
	ASL
	ASL
	ASL
	ASL
	ASL
	STA (ZP4),Y
	LDA TEMP_B
	ASL
	ASL
	ASL
	ASL
	ORA (ZP4),Y
	STA (ZP4),Y
	LDA TEMP_C
	ASL
	ASL
	ORA (ZP4),Y
	STA (ZP4),Y
	LDA TEMP_D
	ORA (ZP4),Y
	STA (ZP4),Y
	INY
	STA (ZP4),Y
	RTS

DISPLAY_MAP: ;Display the entire map on the screen
	LDA #1			;Set a flag that the map is open so the screen doesn't get drawn
	STA MAP_OPEN
	STA MAP_TIMER
	JSR MAP_INIT_UNITS
	LDA #>BITMAP_COLOR_2		;Reset to show all 4 color maps
	STA MAP_COLOR_RAM_ARRAY_H
	LDA #>BITMAP_COLOR_3
	STA MAP_COLOR_RAM_ARRAY_H+1
	LDA #>BITMAP_COLOR_0
	STA MAP_COLOR_RAM_ARRAY_H+2
	LDA #>BITMAP_COLOR_1
	STA MAP_COLOR_RAM_ARRAY_H+3
	JSR MAP_COLOR_RAM_UPDATE
	JSR SCROLL_INFO
	LDA	#<MSG_MAP
	STA	ZP0
	LDA	#>MSG_MAP
	STA	ZP1
	JSR	PRINT_INFO
	JSR SCROLL_INFO
	SEI
	LDA #0
	STA $FF11				;Turn off any playing sound
	JSR MAP_BACKUP			;Backup important data that falls within the range of our color maps, to be restored before returning from map
	JSR MAP_COLUMNS			;Create black columns on the left and right side of the map
	LDA #$2B				;Switch into bitmap mode. Blank screen to draw the map faster
	STA $FF06
	LDA $FF07
	ORA #%00010000
	STA $FF07
	LDA #>TITLE_COLOR_RAM
	STA $FF14
	LDA #$E8
	STA $FF12
	JSR MAP_DRAW			;Draw the bitmap and color data for the map
	LDA #<MAP_IRQ			;Enable the map interrupt, which still calls the normal interrupt
	STA $FFFE
	LDA #>MAP_IRQ
	STA $FFFF
	LDA #26
	STA $FF0B				;Reset the rasterline to the top of the map
	LDA #$02
	STA $FF09				;Acknowledge any attempted interrupt until we reach the new rasterline
	CLI
	JSR CLEAR_KEY_BUFFER
DMLOOP:						
	LDA MAP_CHECK_KEY		;Loop after calling the following code, until the next interrupt finishes
	BEQ DMLOOP
	LDA #0
	STA MAP_CHECK_KEY
	LDA MAP_TIMER
	CMP #1					;Run background tasks every other frame (This var is incremented in the map irq)
	BEQ DMLOOP1
	JSR MAP_DRAW_UNITS
	JMP DMLOOP
DMLOOP1:
	JSR GETKEY
	CMP	#$00
	BEQ DMLOOP2
	CMP #224		;Toggle robots showing
	BNE DM0
	LDA MAP_SHOW_ROBOTS
	EOR #%00000001
	STA MAP_SHOW_ROBOTS
DMLOOP2:
	JSR BACKGROUND_TASKS
	JMP DMLOOP
DM0:
	JSR MAP_RESTORE			;Restore important data that was backed up before showing the mini-map
	JSR SETUP_INTERRUPT		;Resume the normal interrupt
	JSR	DISPLAY_GAME_SCREEN	;Draw the side menu and map, since it got destroyed by the map
	JSR DISPLAY_WEAPON
	JSR DISPLAY_ITEM
	JSR DISPLAY_KEYS
	JSR	CACULATE_AND_REDRAW
	JSR	DRAW_MAP_WINDOW
	JSR	DISPLAY_PLAYER_HEALTH
	LDA #$1B				;Switch back to character mode
	STA $FF06
	LDA $FF07
	AND #%11101111
	STA $FF07
	LDA #>COLOR_RAM
	STA $FF14
	LDA #0
	STA MAP_OPEN
	JSR CLEAR_KEY_BUFFER
	JSR SCROLL_INFO
	JSR SCROLL_INFO
	JSR SCROLL_INFO
	RTS
	
MAP_OPEN: !BYTE $00	;1 = map is open (prevent drawing the screen when it is open), 0 = map is not open
	
MAP_COLOR_RAM_UPDATE
	LDX #4
MCRU0:
	LDA MAP_COLOR_RAM_ARRAY_H
	STA MAP_COLOR_RAM_ARRAY_H,X
	INX
	LDA MAP_COLOR_RAM_ARRAY_H+1
	STA MAP_COLOR_RAM_ARRAY_H,X
	INX
	LDA MAP_COLOR_RAM_ARRAY_H+2
	STA MAP_COLOR_RAM_ARRAY_H,X
	INX
	LDA MAP_COLOR_RAM_ARRAY_H+3
	STA MAP_COLOR_RAM_ARRAY_H,X
	INX
	CPX #64
	BNE MCRU0
	RTS

;IRQ Routine to use while displaying the mini-map
MAP_IRQ:
	PHA				;Push registers onto the stack
	TXA
	PHA
	TYA
	PHA
;MI0000:
;	LDA $FF1C
;	AND #%00000001
;	BNE MI0000		;Loop until high bit of raster is clear
	LDY #28
MI000:
	CPY $FF1D		;Loop until rasterline is hit
	BNE MI000
	LDA $FF07		;Enable Multi-color mode
	ORA #%00010000
	STA $FF07
	LDA MAP_COLOR_BG_DEFAULT
	STA BACKGROUND_COLOR_2
	LDX MAP_VERT_POS
	STX $FF06		;Set initial vertical scroll
	LDA #$71
	STA BACKGROUND_COLOR
	LDX #0			;The row of the map we are working on
MI0:
	INY
MI01:
	CPY $FF1D		;Loop until rasterline is hit
	BCS MI01
	LDA MAP_VERT_POS,X
	STA $FF06
	LDA MAP_COLOR_RAM_ARRAY_H,X
	STA $FF14
	INY
	;Fetch which color to assign to background color 2
	;LDA MAP_ROW_BG,X
	;TAY
	;Increase the row number we are on
	INX
	CPX #62
	BNE MI0
	;Done drawing map
	LDA #0
	STA BACKGROUND_COLOR
	LDX #14
MI3:			;Wait a timed amount of cycles before continuing
	DEX
	BNE MI3
	LDA $FF07
	AND #%11101111
	STA $FF07	;Turn off multi-color mode
	LDA #$1B
	STA $FF06	;Set back to default vertical scroll position and character mode
	LDA MAP_COLOR_RAM_ARRAY+1
	STA $FF14	;Set the character map to the normal in-game characters to show bottom menu
	LDX MAP_TIMER	;Increment a timer to use to know when to run background_tasks
	INX
	CPX #2
	BNE MI4
	LDX #0
MI4:
	STX MAP_TIMER
	INX
	STX MAP_CHECK_KEY
	JMP MAIN_INTERRUPT
	
;Store #$FF for each unit, so we know they aren't currently plotted on the map
MAP_INIT_UNITS:
	LDA #0
	STA MAP_SHOW_ROBOTS
	TAX
MIU0:
	STA UNIT_MAP_A,X
	INX
	CPX #48
	BNE MIU0
	LDA #30
	STA MAP_TIMER_PLAYER
	RTS

;Draw units on the map. First replace their previous background color on the map (in reverse order,
;in case another unit was showing in the same byte) before moving them.
MAP_DRAW_UNITS:
	LDX #48
	LDY #0
MDU0:
	DEX
	LDA UNIT_MAP_A,X
	BEQ MDU1			;Unit not previously plotted, skip
	LDA UNIT_MAP_L,X
	STA ZP0
	LDA UNIT_MAP_H,X
	STA ZP1
	LDA UNIT_MAP_BG,X
	STA (ZP0),Y			;Set the previous byte back on the map that was there before plotting the unit
	INY
	STA (ZP0),Y
	DEY
	LDA #0
	STA UNIT_MAP_A,X	;Set unit as not plotted
MDU1:
	CPX #0
	BNE MDU0
	
MDU5:
	LDA UNIT_TYPE,X
	CMP #1	;player
	BNE MDU6
	LDY MAP_TIMER_PLAYER
	DEY
	STY MAP_TIMER_PLAYER
	CPY #15
	BCS MDUPLOT
	CPY #0
	BNE MDU7
	LDY #30
	STY MAP_TIMER_PLAYER
MDU6:
	LDY MAP_SHOW_ROBOTS
	CPY #1
	BNE MDU8
	CMP #2	;left-right droid
	BEQ MDUPLOT
	CMP #3	;up-down droid
	BEQ MDUPLOT
	CMP #4	;hover attack
	BEQ MDUPLOT
	CMP #5	;water droid
	BEQ MDUPLOT
	CMP #9	;evil bot
	BEQ MDUPLOT
	CMP #12	;pistol fire up
	BEQ MDUPLOT
	CMP #13	;pistol fire down
	BEQ MDUPLOT
	CMP #14	;pistol fire left
	BEQ MDUPLOT
	CMP #15	;pistol fire right
	BEQ MDUPLOT
	CMP #17	;up-down rollerbot
	BEQ MDUPLOT
	CMP #18	;left-right rollerbot
	BEQ MDUPLOT
	CMP #21	;magnetized robot
	BEQ MDUPLOT
	CMP #22	;water raft left-right
	BEQ MDUPLOT
MDU7:
	INX
	CPX #48
	BNE MDU5
MDU8:
	RTS
	
MDUPLOT:
	LDA UNIT_LOC_Y,X		;Fetch the unit's Y location
	TAY
	LDA UNIT_LOC_X,X		;Fetch the unit's Y location
	NOP
	LDA UNIT_LOC_Y,X		;Fetch the unit's Y location
	TAY
	LDA MAP_ROW_L,Y			;Fetch the starting byte/position for that row in the bitmap
	STA UNIT_MAP_L,X		;Store this position. We will add the X position to this later
	LDA MAP_ROW_H,Y
	STA UNIT_MAP_H,X
	LDA	UNIT_LOC_X,X		;Fetch the unit's X location
	AND #%11111100			;Clear the last two bits (0-3) because 4 pixels go in each cell
	ASL						;Multiply by two to get the bitmap byte to edit
	CLC						;Add this number to the original position we stored for the row on the map
	ADC MAP_ROW_L,Y
	STA UNIT_MAP_L,X
	STA ZP0
	LDA UNIT_MAP_H,X
	ADC #0
	STA UNIT_MAP_H,X
	STA ZP1
	LDY #0
	LDA (ZP0),Y				;Store the byte for the background of the map before we place the unit
	STA UNIT_MAP_BG,X
	TAY
	LDA UNIT_LOC_X,X		;Get the last 2 bits of the X location of unit, to figure out which pixel to edit
	AND #%00000011
	BNE MDUP0
	;First pixel of byte
	TYA
	AND #%00111111
	JMP MDUP3
MDUP0:
	CMP #1
	BNE MDUP1
	;Second pixel of byte
	TYA
	AND #%11001111
	JMP MDUP3
MDUP1:
	CMP #2
	BNE MDUP2
	;Third pixel of byte
	TYA
	AND #%11110011
	JMP MDUP3
MDUP2:
	;Fourth pixel of byte
	TYA
	AND #%11111100
MDUP3:
	LDY #0
	STA (ZP0),Y
	INY
	STA (ZP0),Y
	TYA
	STA UNIT_MAP_A,X		;Flag unit as plotted
	JMP MDU7
	